<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Dash Clone</title>

<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }

    #game-container {
        width: 100vw;
        height: 100vh;
        background: black;
    }

    /* Flyttad till h√∂ger nedre h√∂rn */
    .back {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0,0,0,0.5);
        padding: 10px 16px;
        border-radius: 8px;
        color: white;
        text-decoration: none;
        border: 2px solid #666;
        z-index: 9999;
        font-size: 18px;
        cursor: pointer;
    }

    .back:hover {
        background: rgba(40,40,40,0.6);
    }
</style>
</head>
<body>

<!-- St√§ng-knapp som st√§nger fliken -->
<button class="back" onclick="window.close()">‚úñ St√§ng</button>

<div id="game-container">
    <!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Geometry Dash Retro - Ultimate Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #00f3ff; /* Cyan */
            --secondary: #ff00ff; /* Magenta */
            --ship-color: #ffaa00; /* Orange f√∂r ship mode */
            --bg-dark: #050510;
            --bg-light: #1a1a2e;
            --glass: rgba(255, 255, 255, 0.1);
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-dark);
            color: white;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw; 
            height: 100vh; 
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
            border: 2px solid var(--glass);
            background: linear-gradient(180deg, var(--bg-dark) 0%, var(--bg-light) 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Bakgrundseffekt som pulserar */
        #bg-pulse {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at center, rgba(0, 243, 255, 0.05) 0%, transparent 70%);
            z-index: 0;
            pointer-events: none;
        }

        canvas {
            display: block;
            position: relative;
            z-index: 1;
            max-width: 100%; 
            max-height: 100%;
            object-fit: contain;
        }

        /* UI √ñverl√§gg */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(5, 5, 16, 0.9);
            backdrop-filter: blur(8px);
            z-index: 10;
            transition: opacity 0.3s, transform 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none !important;
        }

        h1 {
            font-size: clamp(2.5rem, 6vw, 5rem);
            margin-bottom: 10px;
            text-transform: uppercase;
            text-shadow: 0 0 20px var(--primary);
            background: -webkit-linear-gradient(#fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 4px;
            text-align: center;
        }

        h2 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            color: var(--secondary);
            text-shadow: 0 0 10px var(--secondary);
            text-align: center;
            margin-bottom: 20px;
        }

        p { color: #ccc; font-size: 1rem; text-align: center; max-width: 600px; line-height: 1.5; }

        /* Niv√•v√§ljare */
        .level-grid-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 800px;
            margin: 20px 0;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            border: 1px solid var(--glass);
            flex-grow: 1;
        }

        .lvl-btn {
            background: rgba(0, 243, 255, 0.05);
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 5px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .lvl-btn strong { font-size: 1.4rem; z-index: 2; }
        .lvl-btn span { font-size: 0.6rem; z-index: 2; text-transform: uppercase; margin-top: 2px; }

        .lvl-btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 25px var(--primary);
            transform: scale(1.1);
        }

        .lvl-btn.hard {
            border-color: var(--secondary);
            color: var(--secondary);
            background: rgba(255, 0, 255, 0.05);
        }
        
        .lvl-btn.hard:hover {
            background: var(--secondary);
            color: white;
            box-shadow: 0 0 25px var(--secondary);
        }

        .nav-arrow {
            background: rgba(0,0,0,0.6);
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0 15px;
            transition: 0.2s;
        }
        .nav-arrow:hover { color: var(--primary); transform: scale(1.2); }

        /* Knappar */
        .btn-main {
            margin-top: 20px;
            padding: 15px 50px;
            font-size: 1.5rem;
            background: linear-gradient(90deg, var(--secondary), #aa00aa);
            border: none;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            cursor: pointer;
            border-radius: 50px;
            text-transform: uppercase;
            box-shadow: 0 0 20px var(--secondary);
            transition: transform 0.1s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .btn-main::after {
            content: '';
            position: absolute;
            top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(rgba(255,255,255,0.2), transparent);
            transform: rotate(45deg);
            transition: 0.5s;
            opacity: 0;
        }
        .btn-main:hover::after { opacity: 1; left: 100%; }

        .btn-main:active { transform: scale(0.95); }

        .btn-sub {
            background: transparent;
            border: 2px solid rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.7);
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            margin: 5px;
            font-family: 'Orbitron', sans-serif;
            transition: 0.2s;
        }
        .btn-sub:hover { border-color: white; color: white; background: rgba(255,255,255,0.1); }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px; left: 20px; right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .hud-text { text-shadow: 2px 2px 0 #000; }
        
        .progress-bar-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 6px;
            background: rgba(255,255,255,0.1);
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            box-shadow: 0 0 10px var(--primary);
            transition: width 0.1s linear;
        }

        /* Volymkontroll */
        #sound-toggle {
            position: absolute;
            bottom: 20px; right: 20px;
            font-size: 24px;
            cursor: pointer;
            z-index: 20;
            opacity: 0.7;
            transition: 0.2s;
        }
        #sound-toggle:hover { opacity: 1; transform: scale(1.1); }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="bg-pulse"></div>
        <div class="progress-bar-container"><div id="progress" class="progress-bar"></div></div>
        
        <canvas id="gameCanvas" width="800" height="450"></canvas>

        <div id="hud" class="hidden">
            <div class="hud-text" id="level-display">Niv√• 1</div>
            <div class="hud-text" id="mode-display">CUBE</div>
            <div class="hud-text" id="attempt-display">F√∂rs√∂k: 1</div>
        </div>

        <!-- Huvudmeny -->
        <div id="menu-screen" class="ui-layer">
            <h1>NEON DASH</h1>
            <p>Ultimate Edition ‚Ä¢ H√•ll f√∂r att hoppa ‚Ä¢ Undvik spikar</p>
            <br>
            <button class="btn-main" onclick="showLevelChoose()">Spela</button>
            <div style="margin-top: 20px;">
                <button class="btn-sub" onclick="requestFullscreenHandler()">Fullsk√§rm</button>
                <button class="btn-sub" onclick="showCredits()">Credits</button>
            </div>
        </div>

        <!-- Niv√•v√§ljare -->
        <div id="level-choose-screen" class="ui-layer hidden">
            <h2>V√ÑLJ NIV√Ö</h2>
            <div id="level-group-name" style="margin-bottom: 10px; font-size: 1.2rem; color: var(--primary);"></div>
            <div class="level-grid-container">
                <button class="nav-arrow" onclick="navigateLevels(-1)">&#10094;</button>
                <div class="level-grid" id="level-selector"></div>
                <button class="nav-arrow" onclick="navigateLevels(1)">&#10095;</button>
            </div>
            <button class="btn-sub" onclick="goToMenu()">Tillbaka</button>
        </div>

        <!-- Game Over -->
        <div id="game-over-screen" class="ui-layer hidden">
            <h1 style="color: #ff4444; text-shadow: 0 0 30px red;">KRASCH!</h1>
            <h2 id="fail-percent" style="color: white; text-shadow: none;">95%</h2>
            <button class="btn-main" onclick="retryLevel()">F√∂rs√∂k Igen</button>
            <button class="btn-sub" onclick="goToMenu()">Meny</button>
        </div>

        <!-- Vinst -->
        <div id="win-screen" class="ui-layer hidden">
            <h1 style="color: #44ff44; text-shadow: 0 0 30px lime;">KLARAD!</h1>
            <h2 style="color: white;">Snyggt jobbat!</h2>
            <button class="btn-main" onclick="nextLevel()">N√§sta Niv√•</button>
            <button class="btn-sub" onclick="goToMenu()">Meny</button>
        </div>

        <!-- Credits -->
        <div id="credits-modal" class="ui-layer hidden">
            <h2>UTVECKLAD AV</h2>
            <h1 style="font-size: 3rem; color: var(--primary);">Zayn Lilak</h1>
            <p>Musik & SFX: Syntetiserad i realtid via Web Audio API.</p>
            <p>Inspirerad av RobTop Games.</p>
            <button class="btn-sub" onclick="hideCredits()">St√§ng</button>
        </div>
        
        <div id="sound-toggle" onclick="toggleSound()">üîä</div>
    </div>

    <script>
        /**
         * GEOMETRY DASH RETRO - ULTIMATE EDITION ENGINE
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimering

        // --- AUDIO SYSTEM (Web Audio API) ---
        const AudioSys = {
            ctx: null,
            masterGain: null,
            bgmInterval: null,
            muted: false,
            currentLevelId: 1,

            init: function() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3; 
                this.masterGain.connect(this.ctx.destination);
            },

            playTone: function(freq, type, duration, vol = 1, slideTo = null) {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slideTo) {
                    osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                }

                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            playJump: function() { this.playTone(150, 'square', 0.1, 0.5, 400); },
            playOrb: function() { this.playTone(600, 'sine', 0.2, 0.4, 1200); },
            playPad: function() { this.playTone(100, 'sawtooth', 0.3, 0.5, 300); },
            playPadHigh: function() { this.playTone(200, 'square', 0.4, 0.5, 600); }, // Nytt ljud f√∂r High Pad

            playCrash: function() {
                if (this.muted || !this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                noise.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            },

            playWin: function() {
                [440, 554, 659, 880].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 'square', 0.4, 0.4), i * 150);
                });
            },

            // Genererar toner baserat p√• level-ID f√∂r att skapa unik musik
            getLevelNote: function(levelId, step) {
                // Skalor (Enkelt system)
                const baseFreq = 100 + (levelId * 5); // H√∂gre niv√•er = ljusare/snabbare k√§nsla
                const scale = [0, 3, 5, 7, 10, 12]; // Pentatonisk-ish
                const noteIndex = (step * levelId) % scale.length;
                return baseFreq + (scale[noteIndex] * 10);
            },

            startBGM: function(levelId) {
                if (this.bgmInterval) clearInterval(this.bgmInterval);
                if (!this.ctx) this.init();
                this.currentLevelId = levelId;
                
                let step = 0;
                // Tempo √∂kar lite per niv√•
                const bpm = 120 + (levelId * 2); 
                const stepTime = 60000 / bpm / 4; 

                this.bgmInterval = setInterval(() => {
                    if (this.muted || document.hidden) return;
                    
                    if (step % 4 === 0) {
                        // Kick
                        this.playTone(80, 'sine', 0.1, 0.8, 0.01);
                        pulseBackground();
                    }
                    
                    // Procedural basg√•ng
                    if (step % 2 === 0) {
                        const freq = this.getLevelNote(levelId, Math.floor(step/4));
                        this.playTone(freq, 'sawtooth', 0.15, 0.15);
                    }
                    
                    // Melodi p√• h√∂gre niv√•er
                    if (levelId > 5 && step % 8 === 2) {
                         this.playTone(this.getLevelNote(levelId, step) * 2, 'square', 0.1, 0.05);
                    }

                    step++;
                }, stepTime);
            },

            stopBGM: function() {
                if (this.bgmInterval) clearInterval(this.bgmInterval);
            }
        };

        function toggleSound() {
            AudioSys.muted = !AudioSys.muted;
            document.getElementById('sound-toggle').innerText = AudioSys.muted ? 'üîá' : 'üîä';
            if (!AudioSys.ctx) AudioSys.init();
            if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
        }
        
        function pulseBackground() {
            const bg = document.getElementById('bg-pulse');
            bg.style.opacity = '1';
            setTimeout(() => { bg.style.opacity = '0.3'; }, 100);
        }


        // --- SPELKONSTANTER & VARIABLER ---
        const ORIGINAL_WIDTH = 800;
        const ORIGINAL_HEIGHT = 450;
        const GROUND_Y_RATIO = 380 / 450; 
        
        const GRAVITY_CUBE = 1.3;
        const JUMP_FORCE = -17.5;
        const TERMINAL_VELOCITY = 20;

        const GRAVITY_SHIP = 0.4;
        const THRUST_SHIP = -0.7;
        const MAX_SHIP_SPEED = 8;

        let gameState = 'MENU';
        let currentLevel = 1;
        let attempt = 1;
        let cameraX = 0;
        let levelLength = 0;
        let gameSpeed = 10; 

        let inputState = {
            holding: false,
            pressedThisFrame: false
        };

        let player = {
            x: 100, y: 0, dy: 0, w: 30, h: 30,
            mode: 'CUBE', 
            rotation: 0,
            isGrounded: false,
            isDead: false,
            nearestOrb: null
        };

        let obstacles = [];
        let particles = [];
        let floorParticles = [];

        // --- NIV√ÖDATA (GENERATOR) ---
        const T_BLOCK = 'BLOCK';
        const T_SPIKE = 'SPIKE';
        const T_PAD = 'PAD'; // Gul pad (normal hopp)
        const T_PAD_HIGH = 'PAD_HIGH'; // Lila pad (h√∂gt hopp)
        const T_RING = 'RING';
        const T_SHIP_PORTAL = 'SHIP_PORTAL';
        const T_CUBE_PORTAL = 'CUBE_PORTAL';
        const T_SHIP_CEILING = 'SHIP_CEILING'; 
        const T_SHIP_FLOOR = 'SHIP_FLOOR';
        const T_SPIKE_FLOOR = 'SPIKE_FLOOR'; // Instant death

        const LEVELS = [];

        function generateLevels() {
            for (let i = 1; i <= 20; i++) {
                let diff = "Easy";
                if (i > 5) diff = "Medium";
                if (i > 10) diff = "Hard";
                if (i > 15) diff = "Insane";
                if (i === 20) diff = "Demon";

                let speed = 10.5;

                let lvlData = {
                    id: i,
                    name: getLevelName(i),
                    difficulty: diff,
                    speed: speed,
                    data: createLevelLayout(i)
                };
                LEVELS.push(lvlData);
            }
        }

        function getLevelName(i) {
            const names = [
                "Stereo Start", "Back on Track", "Polargeist", "Dry Out", "Base After Base",
                "Cant Let Go", "Jumper", "Time Machine", "Cycles", "xStep",
                "Clutterfunk", "Theory of All", "Electroman", "Clubstep", "Electrodynamix",
                "Hexagon Force", "Blast Process", "Geometrical", "Deadlocked", "Fingerdash"
            ];
            return names[i-1] || `Level ${i}`;
        }

        function createLevelLayout(lvlNum) {
            let obs = [];
            // Startposition
            let x = 800; 
            const floorY = 380; 

            // Helpers
            const addSpike = (offset) => obs.push([x + offset, floorY, T_SPIKE, 30, 30]);
            const addTripleSpike = (offset) => {
                obs.push([x + offset, floorY, T_SPIKE, 30, 30]);
                obs.push([x + offset + 30, floorY, T_SPIKE, 30, 30]);
                obs.push([x + offset + 60, floorY, T_SPIKE, 30, 30]);
            };
            const addBlock = (offset, h) => obs.push([x + offset, floorY - h, T_BLOCK, 40, h]);
            // Flytande plattform
            const addPlatform = (offset, yFromFloor, w) => obs.push([x + offset, floorY - yFromFloor, T_BLOCK, w, 30]);
            
            const addPad = (offset) => obs.push([x + offset, floorY, T_PAD, 40, 10]);
            const addHighPad = (offset) => obs.push([x + offset, floorY, T_PAD_HIGH, 40, 10]); // Ny helper
            
            const addRing = (offset, height) => obs.push([x + offset, floorY - height, T_RING, 40, 40]);
            
            // Parkour helper med d√∂dligt golv
            const addParkourSection = (difficulty) => {
                let px = 0;
                let steps = difficulty * 2 + 4;
                let currentH = 0;
                let sectionStart = x;
                
                // D√∂dligt golv under hela sektionen
                obs.push([sectionStart, floorY, T_SPIKE_FLOOR, 10000, 30]); 
                
                // F√∂rsta plattformen f√∂r att starta parkouren
                addPlatform(px, 40, 60);
                px += 60; // G√• till kanten av f√∂rsta blocket

                for(let k=0; k<steps; k++) {
                    // Ber√§kna n√§sta h√∂jd
                    let targetH = Math.floor(Math.random() * 3) * 40 + 40; // 40, 80, 120
                    if (targetH > currentH + 40) targetH = currentH + 40;
                    
                    // Avst√•nd - Minska gapen n√•got f√∂r att g√∂ra det mer spelbart men intensivt
                    let gap = 160 + (Math.random() * 40); 
                    
                    // Skapa plattformen
                    addPlatform(px + gap, targetH, 50);
                    
                    // Ibland spik P√Ö plattformen
                    if (lvlNum > 8 && Math.random() > 0.7) {
                        obs.push([x + px + gap + 15, floorY - targetH - 30, T_SPIKE, 20, 20]);
                    }

                    px += gap + 50; // Flytta positionen
                    currentH = targetH;
                }
                
                // Markera golvet efter
                addPlatform(px + 150, 0, 100); // S√§ker landning p√• markniv√•-block
                
                // Uppdatera spike floor l√§ngd
                let spikeFloor = obs.find(o => o.x === sectionStart && o.type === T_SPIKE_FLOOR);
                if(spikeFloor) {
                    spikeFloor.w = px + 100; 
                }
                
                return px + 150;
            };

            let shipStart = 0;
            if (lvlNum >= 3) {
                shipStart = 2000 + (lvlNum * 400); // Variera startpunkten lite
            }

            const length = 76000; 

            // Genereringsloop - Nu med T√ÑTARE intervaller
            while (x < length) {
                // SHIP MODE
                if (shipStart > 0 && x > shipStart && x < shipStart + 1800) {
                    if (!obs.some(o => o[2] === T_SHIP_PORTAL)) {
                        const portalX = x;
                        const portalY = 200;
                        const portalH = 100;
                        obs.push([portalX, portalY, T_SHIP_PORTAL, 50, portalH]);
                        obs.push([portalX, 0, T_SHIP_CEILING, 50, portalY]); 
                        obs.push([portalX, portalY + portalH, T_SHIP_FLOOR, 50, floorY - (portalY + portalH)]);
                    }
                    
                    if (x % 350 < 50) { // T√§tare skepphinder
                        let ceilHeight = 100 + Math.random() * 100;
                        let floorHeight = 80 + Math.random() * 60;
                        obs.push([x + 300, 0, T_SHIP_CEILING, 80, ceilHeight]); 
                        obs.push([x + 300, 380 - floorHeight, T_SHIP_FLOOR, 80, floorHeight]); 
                    }
                    x += 200; // T√§tare loop
                    continue;
                } else if (shipStart > 0 && x > shipStart + 1800 && !obs.some(o => o[2] === T_CUBE_PORTAL)) {
                     const portalTop = 200;
                     const portalHeight = 100;
                     obs.push([x, 0, T_SHIP_CEILING, 50, portalTop]); 
                     obs.push([x, portalTop + portalHeight, T_SHIP_FLOOR, 50, floorY - (portalTop + portalHeight)]); 
                     obs.push([x, portalTop, T_CUBE_PORTAL, 50, portalHeight]);
                     x += 300; 
                     continue;
                }

                // CUBE MODE - T√§tare och mer varierat
                const r = Math.random();
                
                // M√∂nster
                if (r < 0.15) {
                    // Enkel spik eller trippel
                    if (lvlNum > 5 && Math.random() > 0.5) addTripleSpike(0);
                    else addSpike(0);
                    x += 200; // Mycket mindre gap till n√§sta hinder
                } 
                else if (r < 0.30) {
                    // Blocktrappa (t√§tare)
                    addBlock(0, 40); 
                    addBlock(50, 80); // Trappa upp
                    if (lvlNum > 3) addBlock(100, 40); // Ner igen
                    x += 250;
                }
                else if (r < 0.45) {
                    // Pad jump (High eller Low)
                    if (lvlNum > 4 && Math.random() > 0.5) {
                        addHighPad(0); // LILA PAD
                        // M√•ste ha n√•got h√∂gt att landa p√• eller hoppa √∂ver
                        addPlatform(300, 150, 100); // Flytande plattform h√∂gt upp
                    } else {
                        addPad(0); // GUL PAD
                        addBlock(200, 70); // Block att hoppa √∂ver
                    }
                    x += 400;
                }
                else if (r < 0.60) {
                    // "Mid air" plattformar (block i luften)
                    addPlatform(0, 50, 50);
                    addPlatform(180, 90, 50); // N√§sta steg
                    x += 300;
                }
                else if (r < 0.75) {
                     // Parkour-sektion (Mer frekvent nu)
                     let advance = addParkourSection(lvlNum > 10 ? 3 : 1);
                     x += advance;
                }
                else if (r < 0.85) {
                    // Ring
                    addRing(0, 100);
                    addSpike(100); // Spik under ringen
                    x += 300;
                }
                else {
                    // Trap jump
                    if (lvlNum > 6) {
                         const trapX = x + 50;
                         obs.push([trapX, floorY, T_PAD, 40, 10]);
                         obs.push([trapX - 100, 100, T_SHIP_CEILING, 300, 50]); 
                         addPlatform(trapX + 300, 40, 50);
                         x += 400;
                    } else {
                        addBlock(0, 40);
                        x += 150;
                    }
                }
            }
            
            obs.push([length + 200, 0, 'FINISH', 50, 1000]);
            return obs;
        }
        
        generateLevels();

        // --- SETUP & NAVIGERING ---

        const LEVELS_PER_PAGE = 5;
        let currentPage = 0;

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            createLevelButtons(currentPage);
            
            window.addEventListener('keydown', e => {
                if (e.code === 'Space' || e.code === 'ArrowUp') {
                    inputState.holding = true;
                    inputState.pressedThisFrame = true;
                    if (gameState === 'MENU' && e.code === 'Space') showLevelChoose();
                }
            });
            window.addEventListener('keyup', e => {
                if (e.code === 'Space' || e.code === 'ArrowUp') inputState.holding = false;
            });
            
            canvas.addEventListener('mousedown', () => {
                inputState.holding = true;
                inputState.pressedThisFrame = true;
                if (!AudioSys.ctx) AudioSys.init();
            });
            canvas.addEventListener('mouseup', () => inputState.holding = false);
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                inputState.holding = true;
                inputState.pressedThisFrame = true;
                if (!AudioSys.ctx) AudioSys.init();
            }, {passive: false});
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                inputState.holding = false;
            });

            requestAnimationFrame(gameLoop);
        }

        function createLevelButtons(page) {
            const container = document.getElementById('level-selector');
            container.innerHTML = '';
            const start = page * LEVELS_PER_PAGE;
            const end = Math.min(start + LEVELS_PER_PAGE, LEVELS.length);
            
            for (let i = start; i < end; i++) {
                const lvl = LEVELS[i];
                const btn = document.createElement('div');
                btn.className = `lvl-btn ${lvl.difficulty === 'Insane' || lvl.difficulty === 'Demon' ? 'hard' : ''}`;
                btn.onclick = () => startLevel(lvl.id);
                btn.innerHTML = `<strong>${lvl.id}</strong><span>${lvl.name}</span>`;
                container.appendChild(btn);
            }
            
            const groupName = document.getElementById('level-group-name');
            if (LEVELS[start]) groupName.innerText = `${LEVELS[start].difficulty} Levels`;
        }

        function navigateLevels(dir) {
            const maxPages = Math.ceil(LEVELS.length / LEVELS_PER_PAGE);
            currentPage += dir;
            if (currentPage < 0) currentPage = 0;
            if (currentPage >= maxPages) currentPage = maxPages - 1;
            createLevelButtons(currentPage);
        }

        // --- SPELFL√ñDE ---

        function startLevel(id) {
            const lvl = LEVELS[id - 1];
            currentLevel = id;
            gameSpeed = lvl.speed;
            
            obstacles = lvl.data.map(d => ({
                x: d[0], y: d[1], type: d[2], w: d[3], h: d[4], 
                passed: false
            }));
            
            const finish = obstacles.find(o => o.type === 'FINISH');
            levelLength = finish ? finish.x : 10000;

            resetPlayer();
            gameState = 'PLAYING';
            
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('level-choose-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('win-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('level-display').innerText = `${id}. ${lvl.name}`;
            document.getElementById('attempt-display').innerText = `Attempt ${attempt}`;
            
            AudioSys.startBGM(currentLevel);
        }

        function resetPlayer() {
            player.x = 100;
            player.y = 380 - 30; 
            player.dy = 0;
            player.rotation = 0;
            player.mode = 'CUBE';
            player.isDead = false;
            player.isGrounded = true; 
            cameraX = 0;
            inputState.holding = false;
            particles = [];
            floorParticles = [];
        }

        function retryLevel() {
            attempt++;
            startLevel(currentLevel);
        }

        function nextLevel() {
            if (currentLevel < LEVELS.length) {
                currentLevel++;
                attempt = 1;
                startLevel(currentLevel);
            } else {
                goToMenu();
            }
        }

        function die() {
            if (player.isDead) return;
            player.isDead = true;
            AudioSys.playCrash();
            spawnDeathParticles(player.x, player.y);
            
            const can = document.getElementById('gameCanvas');
            can.style.transform = 'translate(5px, 5px)';
            setTimeout(() => can.style.transform = 'none', 50);

            gameState = 'GAMEOVER';
            const pct = Math.floor((cameraX / levelLength) * 100);
            document.getElementById('fail-percent').innerText = `${pct}%`;
            
            setTimeout(() => {
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('hud').classList.add('hidden');
            }, 800);
        }

        function win() {
            if (gameState === 'WIN') return;
            gameState = 'WIN';
            AudioSys.playWin();
            document.getElementById('win-screen').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
        }

        // --- UPDATE LOOP ---

        function update() {
            if (gameState !== 'PLAYING') return;

            if (player.mode === 'CUBE') {
                if (inputState.holding && player.isGrounded) {
                    player.dy = JUMP_FORCE;
                    player.isGrounded = false;
                    AudioSys.playJump();
                } 
                
                if (inputState.pressedThisFrame && player.nearestOrb) {
                    player.dy = JUMP_FORCE * 1.2;
                    player.isGrounded = false;
                    AudioSys.playOrb();
                    spawnOrbParticles(player.nearestOrb.x, player.nearestOrb.y);
                    player.nearestOrb = null;
                }
            } else if (player.mode === 'SHIP') {
                if (inputState.holding) {
                    player.dy += THRUST_SHIP;
                } else {
                    player.dy += GRAVITY_SHIP;
                }
            }

            inputState.pressedThisFrame = false;

            if (player.mode === 'CUBE') {
                player.dy += GRAVITY_CUBE;
                if (player.dy > TERMINAL_VELOCITY) player.dy = TERMINAL_VELOCITY;
                
                if (!player.isGrounded) {
                    player.rotation += 6;
                } else {
                    const r = player.rotation % 360;
                    if (r > 0 && r < 45) player.rotation -= r;
                    else if (r >= 45 && r < 135) player.rotation += (90 - r);
                    else if (r >= 135 && r < 225) player.rotation += (180 - r);
                    else if (r >= 225 && r < 315) player.rotation += (270 - r);
                    else if (r >= 315) player.rotation += (360 - r);
                }
            } else {
                if (player.dy > MAX_SHIP_SPEED) player.dy = MAX_SHIP_SPEED;
                if (player.dy < -MAX_SHIP_SPEED) player.dy = -MAX_SHIP_SPEED;
                player.rotation = player.dy * 3; 
            }

            player.y += player.dy;

            const LOGICAL_FLOOR = 380; 
            if (player.y > LOGICAL_FLOOR - 30) {
                // Den verkliga "marken" utanf√∂r hinder
                player.y = LOGICAL_FLOOR - 30;
                if (player.mode === 'CUBE') {
                    player.dy = 0;
                    player.isGrounded = true;
                    if (Math.random() > 0.8) spawnFloorParticles(player.x, player.y + 30);
                } else {
                    player.dy = 0;
                }
            } else {
                player.isGrounded = false;
            }

            if (player.mode === 'SHIP' && player.y < 0) {
                player.y = 0;
                player.dy = 0;
            }

            cameraX += gameSpeed;
            if (cameraX >= levelLength) win();

            checkCollisions();

            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
            particles = particles.filter(p => p.life > 0);
            
            floorParticles.forEach(p => { p.x -= gameSpeed; p.y -= 0.5; p.life -= 0.03; p.size -= 0.1; });
            floorParticles = floorParticles.filter(p => p.life > 0 && p.size > 0);

            const progress = Math.min(100, (cameraX / levelLength) * 100);
            document.getElementById('progress').style.width = progress + '%';
            document.getElementById('mode-display').innerText = player.mode;
        }

        function checkCollisions() {
            player.nearestOrb = null;
            const playerWorldX = cameraX + 100;
            const renderOffset = cameraX;

            for (let obs of obstacles) {
                if (obs.x < renderOffset - 100 || obs.x > renderOffset + 900) continue;

                const obsX = obs.x;
                const obsY = obs.y;
                
                if (obs.type === T_SPIKE) {
                    if (rectIntersect(playerWorldX + 8, player.y + 8, 14, 14, obsX + 10, obsY - 20, 10, 20)) {
                        die();
                        return;
                    }
                } 
                // INSTANT KILL F√ñR SPIKE FLOOR - Strict collision
                else if (obs.type === T_SPIKE_FLOOR) {
                     // H√§r kollar vi om spelaren ens snuddar omr√•det
                     if (rectIntersect(playerWorldX + 5, player.y + 5, 20, 25, obsX, obsY, obs.w, obs.h)) {
                        die();
                        return;
                    }
                }
                else if (obs.type === T_BLOCK || obs.type === T_SHIP_CEILING || obs.type === T_SHIP_FLOOR) {
                    if (rectIntersect(playerWorldX, player.y, 30, 30, obsX, obsY, obs.w, obs.h)) {
                        if (player.mode === 'SHIP') {
                            die();
                            return; 
                        }
                        
                        const pBottom = player.y + 30;
                        const bTop = obsY;
                        const pRight = playerWorldX + 30;
                        const bLeft = obsX;
                        
                        if ( (obs.type === T_BLOCK || obs.type === T_SHIP_FLOOR) && 
                             player.dy >= 0 && pBottom <= bTop + 20 && pRight > bLeft + 5) 
                        {
                            player.y = bTop - 30;
                            player.dy = 0;
                            player.isGrounded = true;
                            if (player.mode === 'CUBE') player.rotation = 0; 
                        } else {
                            die();
                            return;
                        }
                    }
                }
                else if (obs.type === T_PAD) {
                    if (rectIntersect(playerWorldX, player.y, 30, 30, obsX, obsY - 10, obs.w, 15)) {
                        player.dy = -22; 
                        player.isGrounded = false;
                        AudioSys.playPad();
                        spawnOrbParticles(obsX + 20, obsY);
                    }
                }
                else if (obs.type === T_PAD_HIGH) { // Lila pad - H√∂gre hopp
                    if (rectIntersect(playerWorldX, player.y, 30, 30, obsX, obsY - 10, obs.w, 15)) {
                        player.dy = -28; // Mycket h√∂gre hopp
                        player.isGrounded = false;
                        AudioSys.playPadHigh();
                        spawnOrbParticles(obsX + 20, obsY);
                    }
                }
                else if (obs.type === T_RING) {
                    const centerX = obsX + 20;
                    const centerY = obsY + 20;
                    const pCenterX = playerWorldX + 15;
                    const pCenterY = player.y + 15;
                    const dist = Math.hypot(centerX - pCenterX, centerY - pCenterY);
                    
                    if (dist < 50) { 
                        player.nearestOrb = obs;
                    }
                }
                else if (obs.type === T_SHIP_PORTAL) {
                    if (rectIntersect(playerWorldX, player.y, 30, 30, obsX, obsY, 50, 100)) {
                        if (player.mode !== 'SHIP') {
                            player.mode = 'SHIP';
                            AudioSys.playOrb(); 
                            player.y -= 20;
                        }
                    }
                }
                else if (obs.type === T_CUBE_PORTAL) {
                    if (rectIntersect(playerWorldX, player.y, 30, 30, obsX, obsY, 50, 100)) {
                        if (player.mode !== 'CUBE') {
                            player.mode = 'CUBE';
                            player.rotation = 0;
                            AudioSys.playOrb();
                        }
                    }
                }
            }
        }

        function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
        }

        // --- PARTIKLAR & RENDERING (Samma som f√∂rut) ---
        function spawnDeathParticles(x, y) {
            for(let i=0; i<30; i++) {
                particles.push({
                    x: x + 15, y: y + 15,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    color: i % 2 === 0 ? 'white' : 'red',
                    life: 1.0, size: Math.random() * 5 + 2
                });
            }
        }

        function spawnOrbParticles(x, y) {
            for(let i=0; i<10; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: 'yellow',
                    life: 0.8, size: 3
                });
            }
        }
        
        function spawnFloorParticles(x, y) {
            floorParticles.push({
                x: x, y: y,
                life: 1.0, size: Math.random() * 3 + 1,
                color: 'rgba(255, 255, 255, 0.5)'
            });
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const scaleX = canvas.width / ORIGINAL_WIDTH;
            const scaleY = canvas.height / ORIGINAL_HEIGHT;
            ctx.save();
            ctx.scale(scaleX, scaleY);

            ctx.strokeStyle = '#00f3ff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f3ff';
            ctx.beginPath();
            ctx.moveTo(0, 380);
            ctx.lineTo(800, 380);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.translate(-cameraX + 100, 0); 

            for (let obs of obstacles) {
                if (obs.x < cameraX - 200 || obs.x > cameraX + 1000) continue;

                if (obs.type === T_SPIKE) {
                    ctx.fillStyle = '#ff0055'; 
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y);
                    ctx.lineTo(obs.x + 15, obs.y - 30);
                    ctx.lineTo(obs.x + 30, obs.y);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } 
                else if (obs.type === T_SPIKE_FLOOR) {
                    ctx.fillStyle = 'rgba(255, 0, 85, 0.6)'; // Starkare f√§rg
                    ctx.strokeStyle = '#ff0055';
                    ctx.lineWidth = 2;
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                    
                    for (let i = 0; i < obs.w; i += 30) {
                         if (i > obs.w) break;
                         ctx.fillStyle = '#ff0055'; 
                         ctx.beginPath();
                         ctx.moveTo(obs.x + i, obs.y);
                         ctx.lineTo(obs.x + i + 15, obs.y + 20); 
                         ctx.lineTo(obs.x + i + 30, obs.y);
                         ctx.fill();
                    }
                }
                else if (obs.type === T_BLOCK) {
                    ctx.fillStyle = 'rgba(0, 243, 255, 0.2)';
                    ctx.strokeStyle = '#00f3ff';
                    ctx.lineWidth = 2;
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                    ctx.strokeRect(obs.x + 5, obs.y + 5, obs.w - 10, obs.h - 10);
                }
                else if (obs.type === T_SHIP_CEILING || obs.type === T_SHIP_FLOOR) {
                    ctx.fillStyle = 'rgba(255, 0, 85, 0.2)'; 
                    ctx.strokeStyle = '#ff0055';
                    ctx.lineWidth = 2;
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                }
                else if (obs.type === T_PAD) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(obs.x, obs.y - 5, obs.w, 10);
                    ctx.shadowColor = 'yellow'; ctx.shadowBlur = 15;
                    ctx.fillRect(obs.x + 5, obs.y - 3, obs.w - 10, 4);
                    ctx.shadowBlur = 0;
                    ctx.beginPath(); ctx.arc(obs.x + 20, obs.y, 15, Math.PI, 0); ctx.stroke();
                }
                else if (obs.type === T_PAD_HIGH) { // Lila pad
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(obs.x, obs.y - 5, obs.w, 10);
                    ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 15;
                    ctx.fillRect(obs.x + 5, obs.y - 3, obs.w - 10, 4);
                    ctx.shadowBlur = 0;
                    ctx.beginPath(); ctx.arc(obs.x + 20, obs.y, 15, Math.PI, 0); ctx.stroke();
                }
                else if (obs.type === T_RING) {
                    ctx.beginPath();
                    ctx.arc(obs.x + 20, obs.y + 20, 20, 0, Math.PI*2);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(obs.x + 20, obs.y + 20, 12, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fill();
                }
                else if (obs.type === T_SHIP_PORTAL) {
                    ctx.fillStyle = 'orange';
                    ctx.fillRect(obs.x, obs.y, 40, 90);
                    ctx.strokeStyle = 'white';
                    ctx.strokeRect(obs.x, obs.y, 40, 90);
                }
                else if (obs.type === T_CUBE_PORTAL) {
                    ctx.fillStyle = '#00f3ff';
                    ctx.fillRect(obs.x, obs.y, 40, 90);
                    ctx.strokeStyle = 'white';
                    ctx.strokeRect(obs.x, obs.y, 40, 90);
                }
                else if (obs.type === 'FINISH') {
                    ctx.fillStyle = 'lime';
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(obs.x, 0, 50, 450);
                    ctx.globalAlpha = 1;
                }
            }
            
            floorParticles.forEach(p => {
                ctx.fillStyle = p.color;
                const radius = Math.max(0, p.size);
                ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, Math.PI*2); ctx.fill();
            });

            if (!player.isDead) {
                ctx.save();
                ctx.translate(cameraX + 100 + 15, player.y + 15);
                ctx.rotate(player.rotation * Math.PI / 180);
                
                if (player.mode === 'CUBE') {
                    ctx.fillStyle = '#ffaa00'; 
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.fillRect(-15, -15, 30, 30);
                    ctx.strokeRect(-15, -15, 30, 30);
                    ctx.fillStyle = 'black';
                    ctx.fillRect(5, -5, 8, 8); 
                    ctx.fillRect(5, -12, 4, 4); 
                } else {
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(15, 0);
                    ctx.lineTo(-10, 10);
                    ctx.lineTo(-10, -10);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#00f3ff';
                    ctx.beginPath(); ctx.arc(0, -5, 5, 0, Math.PI*2); ctx.fill();
                    if (inputState.holding) {
                        ctx.fillStyle = 'orange';
                        ctx.beginPath(); ctx.moveTo(-12, 0); ctx.lineTo(-25, 5); ctx.lineTo(-25, -5); ctx.fill();
                    }
                }
                ctx.restore();
            }

            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.max(0, p.size), 0, Math.PI*2); 
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            ctx.restore();
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function showLevelChoose() {
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('level-choose-screen').classList.remove('hidden');
            if(!AudioSys.ctx) AudioSys.init();
        }
        function goToMenu() {
            gameState = 'MENU';
            AudioSys.stopBGM();
            document.getElementById('menu-screen').classList.remove('hidden');
            document.getElementById('level-choose-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('win-screen').classList.add('hidden');
            document.getElementById('hud').classList.add('hidden');
        }
        function showCredits() { document.getElementById('credits-modal').classList.remove('hidden'); }
        function hideCredits() { document.getElementById('credits-modal').classList.add('hidden'); }
        
        function resizeCanvas() {
            const cont = document.getElementById('game-container');
            const ratio = 16/9;
            let w = cont.clientWidth;
            let h = cont.clientHeight;
            if (w/h > ratio) w = h * ratio;
            else h = w / ratio;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
        }
        
        function requestFullscreenHandler() {
            const el = document.documentElement;
            if(el.requestFullscreen) el.requestFullscreen();
            else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        }

        init();
    </script>
</body>
</html>
</div>

</body>
</html>

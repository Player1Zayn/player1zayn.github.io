<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Humpty Dumpty</title>
<style>
body { margin:0; padding:0; background:#000; overflow:hidden; font-family: Arial; color:#fff; }
.menu {
    position: fixed;
    top:0; left:0;
    width:100%; height:100%;
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    background: rgba(30,30,30,0.95);  /* lite transparent men bakgrund */
    z-index: 9999; /* alltid ovanpå canvas */
}
.button {
    padding:15px 30px; margin:10px; font-size:20px;
    color:#fff; background:#007bff; border-radius:10px; cursor:pointer;
    user-select:none;
}
.button:hover { background:#0056b3; transform:scale(1.05); }
canvas { display:block; background:#111; width:100%; height:100vh; }
</style>
</head>
<body>

<!-- MENY -->
<div id="menu" class="menu">
  <h1>Välj ett spel</h1>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let currentGameLoop = null;
let activeGame = null;

// Definiera dina spel här
const games = [
    {name:"Spel 1", func: null}, 
    {name:"Spel 2", func: null},
    {name:"Spel 3", func: null}
];

// Skapa knappar dynamiskt
const menuDiv = document.getElementById('menu');
games.forEach((g, i) => {
    const btn = document.createElement('div');
    btn.className = 'button';
    btn.textContent = g.name;
    btn.onclick = () => startGame(i);
    menuDiv.appendChild(btn);
});

// Starta spel
function startGame(index) {
    document.getElementById('menu').style.display = 'none';
    activeGame = games[index];
    if(activeGame.func) {
        gameLoop();
    } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle="white";
        ctx.font="30px Arial";
        ctx.fillText("Spelkod saknas för " + activeGame.name, 50,50);
    }
}

// ESC för att återgå till menyn
document.addEventListener('keydown', e => {
    if(e.key === "Escape" && activeGame) {
        if(currentGameLoop) cancelAnimationFrame(currentGameLoop);
        activeGame = null;
        currentGameLoop = null;
        document.getElementById('menu').style.display = 'flex';
        ctx.clearRect(0,0,canvas.width,canvas.height);
    }
});

// Huvudloop
function gameLoop() {
    if(activeGame && activeGame.func) {
        activeGame.func(ctx);
        currentGameLoop = requestAnimationFrame(gameLoop);
    }
}

/* --------- HÄR KLISTRAR DU IN DINA SPEL --------- */

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Survival</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * TANK SURVIVAL
 * Uppdatering:
 * - CHEATCODE: Skriv "lol" ingame för auto-aim och auto-fire.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- SPELSTATUS ---
const STATE = {
    MENU: 0,
    PLAYING: 1, // Single player
    MULTIPLAYER: 6, // New mode
    CREDITS: 2,
    GAMEOVER: 3,
    WIN: 4,
    PRACTICE: 5
};

let currentState = STATE.MENU;
let score = 0;
const TARGET_SCORE = 1000;
const TILE_SIZE = 100;

// Practice Mode Variabler
let practiceActive = false;
let practiceDifficulty = 1;

// Cheat Variabler
let cheatString = ""; // För att spara knapptryckningar

// --- LJUDSYSTEM (Web Audio API) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let soundEnabled = false;

let engineOsc = null;
let engineGain = null;

function initAudio() {
    if (soundEnabled) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    engineOsc = audioCtx.createOscillator();
    engineGain = audioCtx.createGain();
    engineOsc.type = 'sawtooth'; 
    engineOsc.frequency.value = 40; 
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 400;
    engineOsc.connect(filter);
    filter.connect(engineGain);
    engineGain.connect(audioCtx.destination);
    engineGain.gain.value = 0;
    engineOsc.start();

    soundEnabled = true;
}

const Sound = {
    shoot: () => {
        if (!soundEnabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
    },
    explosion: () => {
        if (!soundEnabled) return;
        const bufferSize = audioCtx.sampleRate * 0.5;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    },
    wallHit: () => {
        if (!soundEnabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.05);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.05);
    },
    updateEngine: (isMoving) => {
        if (!engineGain) return;
        const targetGain = isMoving ? 0.1 : 0.0; 
        const targetFreq = isMoving ? 60 : 40;
        engineGain.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.1);
        engineOsc.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
    }
};

// --- INPUT HANTERING ---
const activeKeys = {};

window.addEventListener('keydown', (e) => {
    activeKeys[e.key.toLowerCase()] = true;
    activeKeys[e.code] = true;
    
    // Practice Mode
    if (currentState === STATE.PRACTICE) {
        if (e.key === "Enter") practiceActive = !practiceActive;
        if (e.key >= '1' && e.key <= '9') practiceDifficulty = parseInt(e.key);
    }

    // --- CHEAT DETECTION ---
    if (currentState === STATE.PLAYING || currentState === STATE.MULTIPLAYER || currentState === STATE.PRACTICE) {
        cheatString += e.key.toLowerCase();
        // Håll bufferten kort
        if (cheatString.length > 10) cheatString = cheatString.slice(-10);
        
        if (cheatString.endsWith("lol")) {
            // Aktivera fusk på alla levande spelare
            players.forEach(p => {
                if (!p.dead) {
                    p.cheatMode = true;
                    // Visuell feedback (partikel eller liknande kan läggas här om man vill)
                }
            });
            // Rensa strängen så man inte aktiverar det igen direkt av misstag
            cheatString = "";
        }
    }
});

window.addEventListener('keyup', (e) => {
    activeKeys[e.key.toLowerCase()] = false;
    activeKeys[e.code] = false;
});

const mouse = { x: 0, y: 0, clicked: false };
window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => { mouse.clicked = true; });
window.addEventListener('mouseup', () => { mouse.clicked = false; });

// --- OBJEKT & KAMERA ---

let players = [];
let camera = { x: 0, y: 0 };

function updateCamera() {
    if (players.length === 0) return;

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    let activePlayers = 0;

    players.forEach(p => {
        if (!p.dead) {
            if (p.worldX < minX) minX = p.worldX;
            if (p.worldX > maxX) maxX = p.worldX;
            if (p.worldY < minY) minY = p.worldY;
            if (p.worldY > maxY) maxY = p.worldY;
            activePlayers++;
        }
    });

    if (activePlayers === 0) return;

    const targetX = (minX + maxX) / 2;
    const targetY = (minY + maxY) / 2;

    camera.x += (targetX - camera.x) * 0.1;
    camera.y += (targetY - camera.y) * 0.1;
}

function worldToScreen(wx, wy) {
    return {
        x: wx - camera.x + canvas.width / 2,
        y: wy - camera.y + canvas.height / 2
    };
}

// Listor
let bullets = [];
let enemies = [];
let particles = [];
let mines = [];
let tracks = [];

// --- KLASSER ---

class PlayerTank {
    constructor(id, x, y, color, controls) {
        this.id = id;
        this.worldX = x;
        this.worldY = y;
        this.speed = 5;
        this.angle = -Math.PI / 2;
        this.turretAngle = -Math.PI / 2;
        this.radius = 20;
        this.lastShot = 0;
        this.cooldown = 300;
        this.color = color;
        this.controls = controls;
        this.distanceSinceLastTrack = 0;
        this.dead = false;
        this.cheatMode = false; // Default avstängt
    }

    update() {
        if (this.dead) return false;

        let moveX = 0;
        let moveY = 0;
        
        if (activeKeys[this.controls.up]) moveY = -1;
        if (activeKeys[this.controls.down]) moveY = 1;
        if (activeKeys[this.controls.left]) moveX = -1;
        if (activeKeys[this.controls.right]) moveX = 1;

        let isMoving = false;
        if (moveX !== 0 || moveY !== 0) {
            isMoving = true;
            const len = Math.sqrt(moveX*moveX + moveY*moveY);
            moveX /= len;
            moveY /= len;
            
            const nextX = this.worldX + moveX * this.speed;
            const nextY = this.worldY + moveY * this.speed;

            if (!checkWallCollision(nextX, this.worldY, this.radius)) this.worldX = nextX;
            if (!checkWallCollision(this.worldX, nextY, this.radius)) this.worldY = nextY;
            
            this.angle = Math.atan2(moveY, moveX);
            
            this.distanceSinceLastTrack += this.speed;
            if (this.distanceSinceLastTrack > 15) {
                tracks.push(new TrackMark(this.worldX, this.worldY, this.angle));
                this.distanceSinceLastTrack = 0;
            }
        }

        // --- FUSK LOGIK (Auto-aim + Auto-fire) ---
        if (this.cheatMode) {
            // Hitta närmaste fiende
            let closest = null;
            let minDist = Infinity;
            enemies.forEach(e => {
                const d = Math.sqrt((e.worldX - this.worldX)**2 + (e.worldY - this.worldY)**2);
                if (d < minDist) {
                    minDist = d;
                    closest = e;
                }
            });

            if (closest) {
                const dx = closest.worldX - this.worldX;
                const dy = closest.worldY - this.worldY;
                // Sikta direkt mot fienden
                this.turretAngle = Math.atan2(dy, dx);
                
                // Auto skjut (kollar cooldown)
                this.tryShoot();
            } else {
                // Inga fiender? Manuell kontroll på tornet
                const turnSpeed = 0.15;
                if (activeKeys[this.controls.turretLeft]) this.turretAngle -= turnSpeed;
                if (activeKeys[this.controls.turretRight]) this.turretAngle += turnSpeed;
            }

        } else {
            // VANLIG KONTROLL
            const turnSpeed = 0.15;
            if (activeKeys[this.controls.turretLeft]) this.turretAngle -= turnSpeed;
            if (activeKeys[this.controls.turretRight]) this.turretAngle += turnSpeed;
            
            if (activeKeys[this.controls.shoot]) {
                this.tryShoot();
            }
        }

        return isMoving;
    }

    tryShoot() {
        const now = Date.now();
        // Om fuskläge är på, skjut lite snabbare (halverad cooldown) eller normalt?
        // Användaren sa bara "autofire", vi kör normal cooldown så det inte buggar ur helt.
        if (now - this.lastShot > this.cooldown) {
            const barrelLen = 40;
            const bx = this.worldX + Math.cos(this.turretAngle) * barrelLen;
            const by = this.worldY + Math.sin(this.turretAngle) * barrelLen;
            
            if (!checkWallCollision(bx, by, 5)) {
                bullets.push(new Bullet(bx, by, this.turretAngle, false));
                Sound.shoot();
                this.lastShot = now;
                
                const recoilX = this.worldX - Math.cos(this.turretAngle) * 2;
                const recoilY = this.worldY - Math.sin(this.turretAngle) * 2;
                if (!checkWallCollision(recoilX, recoilY, this.radius)) {
                    this.worldX = recoilX;
                    this.worldY = recoilY;
                }
            }
        }
    }

    draw() {
        if (this.dead) return;
        const pos = worldToScreen(this.worldX, this.worldY);
        ctx.save();
        ctx.translate(pos.x, pos.y);
        
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`P${this.id}`, 0, -35);
        
        // Fusk-indikator
        if (this.cheatMode) {
            ctx.fillStyle = '#FFD700';
            ctx.font = '10px Arial';
            ctx.fillText(`(CHEAT)`, 0, -48);
        }

        ctx.save();
        ctx.rotate(this.angle);
        ctx.fillStyle = '#111';
        ctx.fillRect(-22, -24, 44, 10);
        ctx.fillRect(-22, 14, 44, 10);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.fillRect(-20, -18, 40, 36);
        ctx.shadowBlur = 0;
        ctx.restore();

        ctx.rotate(this.turretAngle);
        ctx.fillStyle = '#2E7D32';
        ctx.fillRect(0, -6, 40, 12);
        ctx.strokeStyle = '#1B5E20';
        ctx.strokeRect(0, -6, 40, 12);
        ctx.fillStyle = '#1B5E20'; 
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, Math.PI * 2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }
}

class TrackMark {
    constructor(x, y, angle) {
        this.worldX = x;
        this.worldY = y;
        this.angle = angle;
        this.life = 300;
        this.maxLife = 300;
    }
    update() { this.life--; }
    draw() {
        const pos = worldToScreen(this.worldX, this.worldY);
        if (pos.x < -20 || pos.x > canvas.width + 20 || pos.y < -20 || pos.y > canvas.height + 20) return;
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(this.angle);
        ctx.globalAlpha = (this.life / this.maxLife) * 0.3;
        ctx.fillStyle = '#000';
        ctx.fillRect(-20, -5, 10, 10);
        ctx.fillRect(10, -5, 10, 10);
        ctx.restore();
        ctx.globalAlpha = 1.0;
    }
}

class Bullet {
    constructor(x, y, angle, isEnemy = false) {
        this.worldX = x;
        this.worldY = y;
        this.dx = Math.cos(angle) * 15;
        this.dy = Math.sin(angle) * 15;
        this.life = 100;
        this.isEnemy = isEnemy;
    }
    update() {
        this.worldX += this.dx;
        this.worldY += this.dy;
        this.life--;
    }
    draw() {
        const pos = worldToScreen(this.worldX, this.worldY);
        ctx.fillStyle = this.isEnemy ? '#FF0000' : '#FFD700';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Mine {
    constructor() {
        let valid = false;
        let attempts = 0;
        while(!valid && attempts < 10) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.max(canvas.width, canvas.height) / 1.2 + Math.random() * 500;
            this.worldX = camera.x + Math.cos(angle) * distance;
            this.worldY = camera.y + Math.sin(angle) * distance;
            this.radius = 12;
            if(!checkWallCollision(this.worldX, this.worldY, this.radius + 5)) valid = true;
            attempts++;
        }
        this.blinkTimer = 0;
    }
    update() { this.blinkTimer++; }
    draw() {
        const pos = worldToScreen(this.worldX, this.worldY);
        if (pos.x < -50 || pos.x > canvas.width + 50 || pos.y < -50 || pos.y > canvas.height + 50) return;
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.stroke();
        if (Math.floor(this.blinkTimer / 30) % 2 === 0) {
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

class Enemy {
    constructor(isPractice = false, px = 0, py = 0) {
        this.isPractice = isPractice;
        if (isPractice) {
            this.worldX = px;
            this.worldY = py;
            this.speed = 0;
            this.hp = 1000; 
            this.lastShot = Date.now() - Math.random() * 5000;
        } else {
            let valid = false;
            let attempts = 0;
            while(!valid && attempts < 10) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.max(canvas.width, canvas.height) / 1.5 + 100;
                this.worldX = camera.x + Math.cos(angle) * distance;
                this.worldY = camera.y + Math.sin(angle) * distance;
                this.radius = 20;
                if (!checkWallCollision(this.worldX, this.worldY, this.radius + 10)) valid = true;
                attempts++;
            }
            const diff = Math.floor(score / 10);
            const speedBonus = Math.min(diff * 0.2, 3);
            this.speed = 1 + Math.random() * 1.5 + speedBonus; 
            this.hp = 3;
            this.lastShot = Date.now();
            const coolRed = Math.min(diff * 100, 1500);
            this.cooldown = (2500 + Math.random() * 2000) - coolRed;
        }
        this.radius = 20;
        this.color = isPractice ? '#5555AA' : '#D32F2F'; 
    }

    update() {
        let target = null;
        let minDist = Infinity;

        players.forEach(p => {
            if (!p.dead) {
                const d = Math.sqrt((p.worldX - this.worldX)**2 + (p.worldY - this.worldY)**2);
                if (d < minDist) {
                    minDist = d;
                    target = p;
                }
            }
        });

        if (!target) return; 

        const dx = target.worldX - this.worldX;
        const dy = target.worldY - this.worldY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        this.angle = Math.atan2(dy, dx);

        if (!this.isPractice && dist > 0) {
            let nextX = this.worldX + (dx / dist) * this.speed;
            let nextY = this.worldY + (dy / dist) * this.speed;
            if (checkWallCollision(nextX, this.worldY, this.radius)) nextX = this.worldX; 
            if (checkWallCollision(nextX, nextY, this.radius)) nextY = this.worldY;
            
            if (nextX === this.worldX && nextY === this.worldY) {
                 let tryX = this.worldX + (dx / dist) * this.speed;
                 if (!checkWallCollision(tryX, this.worldY, this.radius)) this.worldX = tryX;
                 else {
                     let tryY = this.worldY + (dy / dist) * this.speed;
                     if (!checkWallCollision(this.worldX, tryY, this.radius)) this.worldY = tryY;
                 }
            } else {
                this.worldX = nextX;
                this.worldY = nextY;
            }
        }
        
        const now = Date.now();
        const pos = worldToScreen(this.worldX, this.worldY);
        const isOnScreen = pos.x > 0 && pos.x < canvas.width && pos.y > 0 && pos.y < canvas.height;

        if (this.isPractice) {
            const practiceCooldown = 3300 - (practiceDifficulty * 300); 
            if (practiceActive && now - this.lastShot > practiceCooldown) {
                 const targetAngle = Math.atan2(dy, dx);
                 bullets.push(new Bullet(this.worldX, this.worldY, targetAngle, true));
                 this.lastShot = now;
            }
        } else {
            if (isOnScreen && dist < 800 && now - this.lastShot > this.cooldown) {
                const targetAngle = Math.atan2(dy, dx);
                bullets.push(new Bullet(this.worldX, this.worldY, targetAngle, true));
                Sound.shoot();
                this.lastShot = now;
            }
        }
    }

    draw() {
        const pos = worldToScreen(this.worldX, this.worldY);
        if (pos.x < -50 || pos.x > canvas.width + 50 || pos.y < -50 || pos.y > canvas.height + 50) return;

        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.fillRect(-20, -18, 40, 36);
        ctx.fillStyle = '#333';
        ctx.fillRect(-20, -22, 40, 6);
        ctx.fillRect(-20, 16, 40, 6);
        ctx.fillStyle = this.isPractice ? '#444499' : '#8e0000';
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(0, -4, 30, 8);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.worldX = x;
        this.worldY = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5;
        this.dx = Math.cos(angle) * speed;
        this.dy = Math.sin(angle) * speed;
        this.life = 30 + Math.random() * 20;
        this.startLife = this.life;
        this.color = color;
        this.size = Math.random() * 8 + 2;
    }
    update() {
        this.worldX += this.dx;
        this.worldY += this.dy;
        this.life--;
        this.size *= 0.95;
    }
    draw() {
        const pos = worldToScreen(this.worldX, this.worldY);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / this.startLife;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// --- VÄRLD ---
function isWallTile(c, r) {
    if (currentState === STATE.PRACTICE) {
        if (Math.abs(c) < 10 && Math.abs(r) < 10) return false;
    }
    if (Math.abs(c) < 2 && Math.abs(r) < 2) return false;
    const val = Math.sin(c * 12.9898 + r * 78.233) * 43758.5453;
    const random = val - Math.floor(val);
    return random < 0.04; 
}

function getTileType(x, y) {
    const val = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 100;
    if (val > 50) return 'sand';
    if (val > 0) return 'darkgrass';
    return 'grass';
}

function checkWallCollision(x, y, radius) {
    const startCol = Math.floor((x - radius) / TILE_SIZE);
    const endCol = Math.floor((x + radius) / TILE_SIZE);
    const startRow = Math.floor((y - radius) / TILE_SIZE);
    const endRow = Math.floor((y + radius) / TILE_SIZE);
    for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
            if (isWallTile(c, r)) {
                const wallX = c * TILE_SIZE;
                const wallY = r * TILE_SIZE;
                const closestX = Math.max(wallX, Math.min(x, wallX + TILE_SIZE));
                const closestY = Math.max(wallY, Math.min(y, wallY + TILE_SIZE));
                const dx = x - closestX;
                const dy = y - closestY;
                if ((dx * dx + dy * dy) < (radius * radius)) return true;
            }
        }
    }
    return false;
}

function drawBackground() {
    const startCol = Math.floor((camera.x - canvas.width/2) / TILE_SIZE);
    const endCol = startCol + (canvas.width / TILE_SIZE) + 2;
    const startRow = Math.floor((camera.y - canvas.height/2) / TILE_SIZE);
    const endRow = startRow + (canvas.height / TILE_SIZE) + 2;

    for (let c = startCol; c < endCol; c++) {
        for (let r = startRow; r < endRow; r++) {
            const screenX = (c * TILE_SIZE) - camera.x + canvas.width / 2;
            const screenY = (r * TILE_SIZE) - camera.y + canvas.height / 2;

            if (isWallTile(c, r)) {
                ctx.fillStyle = '#555'; 
                ctx.fillRect(Math.floor(screenX), Math.floor(screenY), TILE_SIZE + 1, TILE_SIZE + 1);
                ctx.fillStyle = '#777';
                ctx.fillRect(Math.floor(screenX) + 5, Math.floor(screenY) + 5, TILE_SIZE - 10, TILE_SIZE - 10);
            } else {
                const type = getTileType(c, r);
                if (type === 'sand') ctx.fillStyle = '#e6c288';
                else if (type === 'darkgrass') ctx.fillStyle = '#2e7d32';
                else ctx.fillStyle = '#4caf50';

                ctx.fillRect(Math.floor(screenX), Math.floor(screenY), TILE_SIZE + 1, TILE_SIZE + 1);
            }
        }
    }
}

function spawnEnemy() {
    if (currentState !== STATE.PLAYING && currentState !== STATE.MULTIPLAYER) return;
    
    let baseChance = 0.003;
    if (currentState === STATE.MULTIPLAYER) baseChance = 0.005; 

    const difficultyIncrease = Math.floor(score / 10) * 0.0005;

    if (Math.random() < baseChance + difficultyIncrease) {
        enemies.push(new Enemy(false));
    }
}

function spawnMine() {
    if (currentState !== STATE.PLAYING && currentState !== STATE.MULTIPLAYER) return;
    if (Math.random() < 0.005) mines.push(new Mine());
}

function createExplosion(x, y, color = '#FF5722') {
    Sound.explosion(); 
    for(let i=0; i<15; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function resetGame(mode) {
    score = 0;
    camera.x = 0;
    camera.y = 0;
    players = [];
    bullets = [];
    enemies = [];
    mines = [];
    particles = [];
    tracks = []; 

    if (mode === STATE.PLAYING) {
        // Single Player
        players.push(new PlayerTank(1, 0, 0, '#4CAF50', {
            up: 'w', down: 's', left: 'a', right: 'd',
            turretLeft: 'arrowleft', turretRight: 'arrowright', shoot: ' '
        }));
    } else if (mode === STATE.MULTIPLAYER) {
        // 2 Players
        players.push(new PlayerTank(1, -100, 0, '#4CAF50', {
            up: 'w', down: 's', left: 'a', right: 'd',
            turretLeft: 'q', turretRight: 'e', shoot: ' '
        }));
        players.push(new PlayerTank(2, 100, 0, '#2196F3', {
            up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright',
            turretLeft: '.', turretRight: ',', shoot: 'enter'
        }));
    } else if (mode === STATE.PRACTICE) {
        players.push(new PlayerTank(1, 0, 0, '#4CAF50', {
            up: 'w', down: 's', left: 'a', right: 'd',
            turretLeft: 'arrowleft', turretRight: 'arrowright', shoot: ' '
        }));

        const count = 8;
        const rad = 400;
        for(let i=0; i<count; i++) {
            const angle = (Math.PI * 2 / count) * i;
            const ex = Math.cos(angle) * rad;
            const ey = Math.sin(angle) * rad;
            enemies.push(new Enemy(true, ex, ey));
        }
        practiceActive = false;
        practiceDifficulty = 1;
    }
}

function update() {
    if (currentState !== STATE.PLAYING && currentState !== STATE.PRACTICE && currentState !== STATE.MULTIPLAYER) {
        Sound.updateEngine(false); 
        return;
    }

    let anyoneMoving = false;
    let allDead = true;
    let anyCheatActive = false; // För UI
    
    players.forEach(p => {
        if (!p.dead) {
            allDead = false;
            if (p.update()) anyoneMoving = true;
            if (p.cheatMode) anyCheatActive = true;
        }
    });
    
    if (allDead) {
        currentState = STATE.GAMEOVER;
        return;
    }

    updateCamera();
    Sound.updateEngine(anyoneMoving); 

    enemies.forEach((e) => e.update());
    mines.forEach((m) => m.update());
    for (let i = tracks.length - 1; i >= 0; i--) {
        tracks[i].update();
        if (tracks[i].life <= 0) tracks.splice(i, 1);
    }
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.update();
        if (checkWallCollision(b.worldX, b.worldY, 5)) {
            createExplosion(b.worldX, b.worldY, '#888'); 
            Sound.wallHit(); 
            bullets.splice(i, 1);
            continue;
        }
        if (b.life <= 0) bullets.splice(i, 1);
    }
    particles.forEach((p, index) => {
        p.update();
        if (p.life <= 0) particles.splice(index, 1);
    });

    // Kollisioner
    for (let i = mines.length - 1; i >= 0; i--) {
        const m = mines[i];
        let exploded = false;
        players.forEach(p => {
            if (!p.dead) {
                const dist = Math.sqrt((p.worldX - m.worldX)**2 + (p.worldY - m.worldY)**2);
                if (dist < p.radius + m.radius) {
                    createExplosion(m.worldX, m.worldY, '#ff0000');
                    p.dead = true;
                    createExplosion(p.worldX, p.worldY, p.color);
                    exploded = true;
                }
            }
        });
        if (exploded) { mines.splice(i, 1); continue; }
        if (currentState !== STATE.PRACTICE) {
            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                const dist = Math.sqrt((e.worldX - m.worldX)**2 + (e.worldY - m.worldY)**2);
                if (dist < e.radius + m.radius) {
                    createExplosion(m.worldX, m.worldY, '#ff0000');
                    enemies.splice(j, 1);
                    mines.splice(i, 1);
                    break;
                }
            }
        }
    }

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (b.isEnemy) {
            players.forEach(p => {
                if (!p.dead) {
                    const dist = Math.sqrt((b.worldX - p.worldX)**2 + (b.worldY - p.worldY)**2);
                    if (dist < p.radius + 5) {
                        createExplosion(p.worldX, p.worldY, p.color);
                        p.dead = true;
                        bullets.splice(i, 1);
                    }
                }
            });
        }
    }

    enemies.forEach((e) => {
        players.forEach(p => {
            if (!p.dead) {
                const dist = Math.sqrt((p.worldX - e.worldX)**2 + (p.worldY - e.worldY)**2);
                if (dist < p.radius + e.radius) {
                    createExplosion(p.worldX, p.worldY, p.color);
                    p.dead = true;
                }
            }
        });
    });

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (b.isEnemy) continue; 
        for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            const dist = Math.sqrt((b.worldX - e.worldX)**2 + (b.worldY - e.worldY)**2);
            if (dist < e.radius + 5) {
                createExplosion(e.worldX, e.worldY);
                bullets.splice(i, 1);
                if (currentState === STATE.PRACTICE) {
                    enemies[j] = new Enemy(true, e.worldX, e.worldY);
                } else {
                    enemies.splice(j, 1);
                    score += 1;
                    if (score >= TARGET_SCORE) currentState = STATE.WIN;
                }
                i = bullets.length; 
                break; 
            }
        }
    }

    spawnEnemy();
    spawnMine();
}

// --- RITA ---

function drawUI() {
    ctx.fillStyle = 'white';
    ctx.font = '24px "Courier New"';
    ctx.textAlign = 'left';
    
    if (currentState === STATE.PRACTICE) {
        ctx.fillText(`PRACTICE MODE`, 20, 40);
        ctx.font = '18px "Courier New"';
        ctx.fillStyle = practiceActive ? '#FF4444' : '#44FF44';
        ctx.fillText(`Skjutande: ${practiceActive ? "PÅ" : "AV"} (Enter)`, 20, 70);
        ctx.fillStyle = '#FFD700';
        ctx.fillText(`Svårighet: ${practiceDifficulty} (1-9)`, 20, 100);
    } else {
        const level = Math.floor(score / 10) + 1;
        ctx.fillText(`Poäng: ${score} / ${TARGET_SCORE}`, 20, 40);
        ctx.font = '18px "Courier New"';
        ctx.fillStyle = '#FFD700';
        ctx.fillText(`Hotnivå: ${level}`, 20, 70);
    }
    
    // Global cheat text
    players.forEach(p => {
         if (p.cheatMode && !p.dead) {
             ctx.save();
             ctx.fillStyle = '#FFD700';
             ctx.font = 'bold 20px Arial';
             ctx.textAlign = 'center';
             ctx.fillText("CHEAT ACTIVATED", canvas.width/2, 100);
             ctx.restore();
         }
    });

    ctx.font = '14px "Courier New"';
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.textAlign = 'left';
    if (currentState === STATE.MULTIPLAYER) {
        ctx.fillText("P1: WASD | Q/E Torn | SPACE Skjut", 20, canvas.height - 40);
        ctx.fillText("P2: PILAR | . , Torn | ENTER Skjut", 20, canvas.height - 20);
    } else {
        ctx.fillText("WASD: Kör | PILAR: Sikta | SPACE: Skjut", 20, canvas.height - 20);
    }
}

function drawButton(text, x, y, width, height, isHover) {
    ctx.fillStyle = isHover ? '#66bb6a' : '#333';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.fillRect(x, y, width, height);
    ctx.strokeRect(x, y, width, height);
    ctx.fillStyle = '#fff';
    ctx.font = '30px "Courier New"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x + width / 2, y + height / 2);
}

function isMouseInside(rect) {
    return mouse.x > rect.x && mouse.x < rect.x + rect.w &&
           mouse.y > rect.y && mouse.y < rect.y + rect.h;
}

function drawMenu() {
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0,0, canvas.width, canvas.height);
    ctx.fillStyle = '#4CAF50';
    ctx.font = 'bold 60px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText("TANK SURVIVAL", canvas.width / 2, canvas.height / 2 - 160);
    
    const btnW = 260;
    const btnH = 50;
    const startRect = { x: canvas.width/2 - btnW/2, y: canvas.height/2 - 70, w: btnW, h: btnH };
    const multiRect = { x: canvas.width/2 - btnW/2, y: canvas.height/2, w: btnW, h: btnH };
    const practiceRect = { x: canvas.width/2 - btnW/2, y: canvas.height/2 + 70, w: btnW, h: btnH };
    const creditRect = { x: canvas.width/2 - btnW/2, y: canvas.height/2 + 140, w: btnW, h: btnH };
    
    drawButton("1 PLAYER", startRect.x, startRect.y, startRect.w, startRect.h, isMouseInside(startRect));
    drawButton("2 PLAYERS", multiRect.x, multiRect.y, multiRect.w, multiRect.h, isMouseInside(multiRect));
    drawButton("PRACTICE", practiceRect.x, practiceRect.y, practiceRect.w, practiceRect.h, isMouseInside(practiceRect));
    drawButton("CREDITS", creditRect.x, creditRect.y, creditRect.w, creditRect.h, isMouseInside(creditRect));

    if (mouse.clicked) {
        initAudio();
        if (isMouseInside(startRect)) {
            resetGame(STATE.PLAYING);
            currentState = STATE.PLAYING;
            mouse.clicked = false;
        } else if (isMouseInside(multiRect)) {
            resetGame(STATE.MULTIPLAYER);
            currentState = STATE.MULTIPLAYER;
            mouse.clicked = false;
        } else if (isMouseInside(practiceRect)) {
            resetGame(STATE.PRACTICE);
            currentState = STATE.PRACTICE;
            mouse.clicked = false;
        } else if (isMouseInside(creditRect)) {
            currentState = STATE.CREDITS;
            mouse.clicked = false;
        }
    }
}

function drawCredits() {
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.fillRect(0,0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '40px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText("CREDITS", canvas.width / 2, canvas.height / 2 - 50);
    ctx.fillStyle = '#4CAF50';
    ctx.font = 'bold 30px "Courier New"';
    ctx.fillText("Zayn Lilak", canvas.width / 2, canvas.height / 2 + 20);
    
    const btnW = 200;
    const btnH = 50;
    const backRect = { x: canvas.width/2 - btnW/2, y: canvas.height/2 + 100, w: btnW, h: btnH };
    drawButton("Tillbaka", backRect.x, backRect.y, backRect.w, backRect.h, isMouseInside(backRect));
    
    if (mouse.clicked && isMouseInside(backRect)) {
        currentState = STATE.MENU;
        mouse.clicked = false;
    }
}

function drawGameOver(win) {
    Sound.updateEngine(false);
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0,0, canvas.width, canvas.height);
    ctx.textAlign = 'center';
    if (win) {
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 60px "Courier New"';
        ctx.fillText("UPPDRAG SLUTFÖRT!", canvas.width / 2, canvas.height / 2 - 50);
        ctx.font = '30px "Courier New"';
        ctx.fillStyle = '#fff';
        ctx.fillText("Ni nådde 1000 poäng!", canvas.width / 2, canvas.height / 2 + 10);
    } else {
        ctx.fillStyle = '#D32F2F';
        ctx.font = 'bold 60px "Courier New"';
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 50);
        ctx.font = '30px "Courier New"';
        ctx.fillStyle = '#fff';
        ctx.fillText(`Poäng: ${score}`, canvas.width / 2, canvas.height / 2 + 10);
    }

    const btnW = 250;
    const btnH = 60;
    const menuRect = { x: canvas.width/2 - btnW/2, y: canvas.height/2 + 80, w: btnW, h: btnH };
    drawButton("Huvudmeny", menuRect.x, menuRect.y, menuRect.w, menuRect.h, isMouseInside(menuRect));
    
    if (mouse.clicked && isMouseInside(menuRect)) {
        currentState = STATE.MENU;
        mouse.clicked = false;
    }
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (currentState === STATE.PLAYING || currentState === STATE.PRACTICE || currentState === STATE.MULTIPLAYER) {
        update();
        drawBackground();
        tracks.forEach(t => t.draw());
        particles.forEach(p => p.draw());
        mines.forEach(m => m.draw());
        enemies.forEach(e => e.draw());
        bullets.forEach(b => b.draw());
        players.forEach(p => p.draw());
        drawUI();
    } 
    else if (currentState === STATE.MENU) {
        drawBackground();
        if(players.length === 0) resetGame(STATE.PLAYING);
        players.forEach(p => p.draw());
        drawMenu();
    }
    else if (currentState === STATE.CREDITS) drawCredits();
    else if (currentState === STATE.GAMEOVER) {
        drawBackground();
        mines.forEach(m => m.draw());
        enemies.forEach(e => e.draw());
        particles.forEach(p => p.draw());
        drawGameOver(false);
    }
    else if (currentState === STATE.WIN) {
        drawBackground();
        players.forEach(p => p.draw());
        drawGameOver(true);
    }
    requestAnimationFrame(loop);
}

resetGame(STATE.PLAYING);
currentState = STATE.MENU;

loop();

</script>
</body>
</html>
};

// Exempelspel 2
games[1].func = function(ctx){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="green";
    ctx.beginPath();
    ctx.arc(Math.random()*canvas.width, Math.random()*canvas.height, 30,0,Math.PI*2);
    ctx.fill();
};

// Exempelspel 3
games[2].func = function(ctx){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="blue";
    ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 60,60);
};
</script>

</body>
</html>

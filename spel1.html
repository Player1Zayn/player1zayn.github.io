<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Last Defence</title>

<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }

    #game-container {
        width: 100vw;
        height: 100vh;
        background: black;
    }

    /* Flyttad till höger nedre hörn */
    .back {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0,0,0,0.5);
        padding: 10px 16px;
        border-radius: 8px;
        color: white;
        text-decoration: none;
        border: 2px solid #666;
        z-index: 9999;
        font-size: 18px;
        cursor: pointer;
    }

    .back:hover {
        background: rgba(40,40,40,0.6);
    }
</style>
</head>
<body>

<!-- Stäng-knapp som stänger fliken -->
<button class="back" onclick="window.close()">✖ Stäng</button>

<div id="game-container">
    <!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Defence - Survival</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            overflow: hidden;
            margin: 0;
        }
        
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
            background-color: #388E3C;
            background-image: radial-gradient(#4CAF50 5%, transparent 5%), radial-gradient(#2E7D32 5%, transparent 5%);
            background-size: 40px 40px;
            background-position: 0 0, 20px 20px;
            display: none;
        }
        
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }
        
        .ui-element {
            pointer-events: auto;
        }

        .menu-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 400px;
            z-index: 50;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            background-color: #4a5568;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .menu-button:hover:not(:disabled) {
            background-color: #2d3748;
        }
        .menu-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .menu-button:last-child {
            margin-bottom: 0;
        }

        .letter-style {
            background-color: #fffaf0;
            color: #4a4a4a;
            padding: 2.5rem;
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-family: serif;
            line-height: 1.6;
            text-align: left;
            border: 1px solid #e0e0e0;
        }

        /* Uppdaterad grid för fler resurser */
        .resource-board {
            position: absolute;
            top: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-family: monospace;
            font-size: 0.9rem;
            display: grid;
            grid-template-columns: auto auto; 
            gap: 0.3rem 1rem;
        }

        #material-board { left: 20px; }
        #stats-board { right: 20px; }

        .resource-board .label { color: #a0aec0; }
        .resource-board .value { color: #ffffff; font-weight: 600; text-align: right; }

        #actions-board {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 1rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .action-button {
            display: block;
            width: 100%;
            padding: 0.5rem 1rem;
            margin-top: 0.5rem;
            background-color: #4a5568;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .action-button:hover { background-color: #2d3748; }

        #build-menu {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 1rem;
            z-index: 40;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            width: 250px; 
        }
        
        #troop-select-menu, #building-menu {
            position: absolute; 
            background-color: rgba(30, 41, 59, 0.95); 
            padding: 0.75rem; 
            border-radius: 8px; 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 40;
            width: 250px;
        }
        #building-menu .menu-button {
            margin-bottom: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <canvas id="game-canvas"></canvas>

    

<div class="ui-container">

        

<div id="start-menu" class="menu-screen ui-element">
            <h1 class="text-3xl font-bold text-center mb-6 text-red-400">Last Defence</h1>
            <button id="start-game-intro-btn" class="menu-button">Starta Spel</button>
            <button id="sandbox-game-btn" class="menu-button">Sandbox</button>
            <button id="controls-btn" class="menu-button">Kontroller</button>
            <button id="credits-btn" class="menu-button bg-gray-600 hover:bg-gray-700">Credits</button>
        </div>

        

<div id="intro-screen" class="menu-screen ui-element hidden">
            <h1 class="text-2xl font-bold text-center mb-6 text-red-400">Meddelande från de Överlevande</h1>
            <div class="letter-style text-sm mb-6">
                <p>Kära ledare,</p>
                <p class="mt-4 indent-4">Monster har tagit över nästan hela världen, flera länder har fallit. Du och några modiga själar har startat ett nytt samhälle, och det är ditt jobb att säkra mänskligheten från att utrotas.</p>
                <p class="mt-4 text-right">Lycka till,</p>
                <p class="text-right">Rådet.</p>
            </div>
            <button id="continue-game-btn" class="menu-button bg-green-600 hover:bg-green-700">Fortsätt till Spel</button>
        </div>

        

<div id="credits-screen" class="menu-screen ui-element hidden">
            <h1 class="text-2xl font-bold text-center mb-6">Credits</h1>
            <p class="text-center mb-6 text-xl">Spelet skapat av:</p>
            <p class="text-center text-4xl font-bold text-yellow-400">Zayn Lilak</p>
            <button id="credits-back-btn" class="menu-button mt-6">Tillbaka</button>
        </div>

        

<div id="controls-menu" class="menu-screen ui-element hidden">
            <h1 class="text-2xl font-bold text-center mb-6">Kontroller</h1>
            <ul class="list-disc list-inside space-y-2 mb-6">
                <li><span class="font-bold">WASD / Pilar:</span> Panorera kameran</li>
                <li><span class="font-bold">Scrollhjul:</span> Zooma in/ut</li>
                <li><span class="font-bold">Musdrag:</span> Panorera kameran</li>
                <li><span class="font-bold">Vänsterklick:</span> Välj ruta / Interagera</li>
                <li><span class="font-bold">Högerklick (Övergett Hus):</span> Öppna truppval-meny</li>
                <li><span class="font-bold">Högerklick (Byggnad/Bas):</span> Meny för Uppgradering/Reparation</li>
                <li><span class="font-bold">M (Sandbox):</span> Spawna slumpmässig fiende</li>
                <li><span class="font-bold">B (Sandbox):</span> Spawna Boss</li>
                <li><span class="font-bold">Y:</span> Öppna/Stäng Åtgärdsmeny</li>
                <li><span class="font-bold text-yellow-400">L:</span> Pausa Spel</li>
            </ul>
            <button id="controls-back-btn" class="menu-button">Tillbaka</button>
        </div>
        
        

<div id="pause-menu" class="menu-screen ui-element hidden">
            <h1 class="text-2xl font-bold text-center mb-6 text-blue-300">Pausad</h1>
            <button id="pause-continue-btn" class="menu-button bg-green-600 hover:bg-green-700">Fortsätt</button>
            <button id="pause-controls-btn" class="menu-button">Kontroller</button>
            <button id="pause-home-btn" class="menu-button bg-red-600 hover:bg-red-700">Hemmeny</button>
        </div>

        

<div id="game-over-screen" class="menu-screen ui-element hidden">
            <h1 class="text-3xl font-bold text-center mb-6 text-red-600">GAME OVER</h1>
            <p class="text-center mb-6">Din bas har förstörts.</p>
            <button id="game-over-back-btn" class="menu-button">Till Huvudmenyn</button>
        </div>

        

<div id="game-ui" class="hidden">
            
            

<div id="material-board" class="resource-board ui-element">
                <span class="label">Metal:</span><span id="metal-value" class="value">0</span>
                <span class="label">Wood:</span><span id="wood-value" class="value">0</span>
                <span class="label">Earth:</span><span id="earth-value" class="value">0</span>
                <span class="label">Reinf. Metal:</span><span id="reinforced-metal-value" class="value">0</span>
                <!-- NYA RESURSER -->
                <span class="label text-purple-400">M.Waste:</span><span id="monster-waste-value" class="value text-purple-400">0</span>
                <span class="label text-yellow-200">Bonemeal:</span><span id="bonemeal-value" class="value text-yellow-200">0</span>
            </div>

            

<div id="stats-board" class="resource-board ui-element">
                <span class="label">Kills:</span><span id="kills-value" class="value">0</span>
                <span class="label">Base HP:</span><span id="base-hp-value" class="value">100</span>
                <span class="label">Bullets:</span><span id="bullets-value" class="value">0</span>
                <span class="label">Food:</span><span id="food-value" class="value">0</span>
                <span class="label">Inhabitants:</span><span id="inhabitants-value" class="value">0/0</span>
                <span class="label">Troops:</span><span id="troops-value" class="value">0</span>
            </div>

            

<div id="actions-board" class="ui-element hidden">
                <h4 class="text-lg font-bold mb-2 text-center">Åtgärder & Crafting</h4>
                <button id="train-troop-btn" class="action-button">Träna Trupp (1 Inb, 10 Mat)</button>
                <button id="craft-bullets-btn" class="action-button">Skapa Skott (1 Metal -> 10 Skott)</button>
                <button id="craft-reinforced-btn" class="action-button">Skapa F. Metal (2 Metal -> 1 F.Me)</button>
                <!-- NY CRAFTING -->
                <button id="craft-bonemeal-btn" class="action-button text-yellow-300">Krossa Ben (1 Waste -> 5 Bone)</button>
            </div>

            

<div id="build-menu" class="ui-element hidden">
                <h3 class="text-lg font-bold mb-4">Bygg</h3>
                <button id="build-tower-btn" class="menu-button text-sm"></button>
                <button id="build-wall-btn" class="menu-button text-sm"></button>
                <button id="build-house-btn" class="menu-button text-sm"></button>
                <button id="build-greenhouse-btn" class="menu-button text-sm"></button>
                <button id="build-barracks-btn" class="menu-button text-sm"></button>
                <!-- NYA BYGGNADER -->
                <button id="build-farm-btn" class="menu-button text-sm text-yellow-200"></button>
                <button id="build-mine-btn" class="menu-button text-sm text-gray-300"></button>
                
                <button id="build-cancel-btn" class="menu-button text-sm bg-gray-600">Avbryt</button>
            </div>
            
            

<div id="troop-select-menu" class="ui-element hidden">
                <h4 class="text-sm font-bold mb-3 text-yellow-400 text-center">Skicka Trupper</h4>
                <p class="text-xs mb-3 text-gray-300">Välj antal trupper att skicka för att rädda invånaren (5 Mat kostnad):</p>
                <button data-troops="1" class="menu-button text-xs py-1.5 px-3">1 Trupp (Liten belöning)</button>
                <button data-troops="5" class="menu-button text-xs py-1.5 px-3">5 Trupper (Mellan belöning)</button>
                <button data-troops="10" class="menu-button text-xs py-1.5 px-3">10 Trupper (Stor belöning)</button>
                <button id="troop-select-cancel-btn" class="menu-button text-xs py-1.5 px-3 bg-gray-600 mt-2">Avbryt</button>
            </div>

            

<div id="building-menu" class="ui-element hidden">
                <h4 id="building-menu-title" class="text-lg font-bold mb-3 text-center text-blue-300"></h4>
                <button id="repair-btn" class="menu-button text-sm bg-green-600 hover:bg-green-700 hidden">Reparera (1 F.Metal)</button>
                <button id="upgrade-btn" class="menu-button text-sm bg-blue-600 hover:bg-blue-700"></button>
                <button id="destroy-btn" class="menu-button text-sm bg-red-600 hover:bg-red-700"></button>
                <button id="building-menu-cancel-btn" class="menu-button text-sm bg-gray-600 hover:bg-gray-700">Avbryt</button>
            </div>
        </div>
        
        <div id="sandbox-message" class="hidden ui-element absolute bottom-10 left-1/2 -translate-x-1/2 bg-yellow-600 text-black p-3 rounded-lg font-bold text-center">
            Sandbox-läge: Tryck 'M' för slumpmässig fiende, 'B' för Boss. Tryck 'Y' för Åtgärdsmeny.
        </div>

    </div>

    <script>
        // DOM-element
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        const startMenu = document.getElementById('start-menu');
        const introScreen = document.getElementById('intro-screen'); 
        const creditsScreen = document.getElementById('credits-screen'); 
        const controlsMenu = document.getElementById('controls-menu');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameUi = document.getElementById('game-ui');
        const buildMenu = document.getElementById('build-menu');
        const sandboxMessage = document.getElementById('sandbox-message');
        const actionsBoard = document.getElementById('actions-board');
        const troopSelectMenu = document.getElementById('troop-select-menu');
        
        // Pausmeny
        const pauseMenu = document.getElementById('pause-menu');
        const pauseContinueBtn = document.getElementById('pause-continue-btn');
        const pauseControlsBtn = document.getElementById('pause-controls-btn');
        const pauseHomeBtn = document.getElementById('pause-home-btn');

        // Byggnadsmeny-element
        const buildingMenu = document.getElementById('building-menu');
        const buildingMenuTitle = document.getElementById('building-menu-title');
        const upgradeBtn = document.getElementById('upgrade-btn');
        const destroyBtn = document.getElementById('destroy-btn');
        const repairBtn = document.getElementById('repair-btn');
        const buildingMenuCancelBtn = document.getElementById('building-menu-cancel-btn');

        // Truppval
        const troopSelectCancelBtn = document.getElementById('troop-select-cancel-btn');
        const troopSelectButtons = troopSelectMenu.querySelectorAll('[data-troops]');

        // Knappar
        const startGameIntroBtn = document.getElementById('start-game-intro-btn'); 
        const continueGameBtn = document.getElementById('continue-game-btn'); 
        const sandboxGameBtn = document.getElementById('sandbox-game-btn');
        const controlsBtn = document.getElementById('controls-btn');
        const creditsBtn = document.getElementById('credits-btn'); 
        const creditsBackBtn = document.getElementById('credits-back-btn'); 
        const controlsBackBtn = document.getElementById('controls-back-btn');
        const gameOverBackBtn = document.getElementById('game-over-back-btn');
        
        // Byggknappar
        const buildTowerBtn = document.getElementById('build-tower-btn');
        const buildWallBtn = document.getElementById('build-wall-btn');
        const buildHouseBtn = document.getElementById('build-house-btn');
        const buildGreenhouseBtn = document.getElementById('build-greenhouse-btn');
        const buildBarracksBtn = document.getElementById('build-barracks-btn');
        const buildFarmBtn = document.getElementById('build-farm-btn'); // NY
        const buildMineBtn = document.getElementById('build-mine-btn'); // NY
        const buildCancelBtn = document.getElementById('build-cancel-btn');
        
        // Åtgärds-knappar
        const trainTroopBtn = document.getElementById('train-troop-btn');
        const craftBulletsBtn = document.getElementById('craft-bullets-btn');
        const craftReinforcedBtn = document.getElementById('craft-reinforced-btn');
        const craftBonemealBtn = document.getElementById('craft-bonemeal-btn'); // NY

        // Resurs-UI
        const killsValue = document.getElementById('kills-value');
        const baseHpValue = document.getElementById('base-hp-value');
        const troopsValue = document.getElementById('troops-value');
        const metalValue = document.getElementById('metal-value');
        const bulletsValue = document.getElementById('bullets-value');
        const woodValue = document.getElementById('wood-value');
        const foodValue = document.getElementById('food-value');
        const earthValue = document.getElementById('earth-value');
        const reinforcedMetalValue = document.getElementById('reinforced-metal-value');
        const inhabitantsValue = document.getElementById('inhabitants-value');
        const monsterWasteValue = document.getElementById('monster-waste-value'); // NY
        const bonemealValue = document.getElementById('bonemeal-value'); // NY


        // Spelvariabler
        let gameState = 'MENU';
        let gameMode = 'NORMAL';
        let savedGameState = null; // För att komma ihåg om vi var i GAME eller SANDBOX innan paus
        let lastTime = 0;
        const TILE_SIZE = 50;

        // Spelobjekt (listor)
        let world = {}; 
        let base;
        let towers = [];
        let walls = [];
        let houses = [];
        let greenhouses = [];
        let barracks = [];
        let farms = []; // NY
        let mines = []; // NY
        let abandonedHouses = [];
        let monsters = [];
        let projectiles = [];
        let troops = []; 
        
        let selectedTile = null;
        let targetAbandonedHouse = null; 
        let focusedBuilding = null;

        let monsterSpawnTimer = 0;
        let abandonedHouseSpawnTimer = 0;
        let inhabitantGrowTimer = 0;
        const MONSTER_SPAWN_RATE = 3000;
        const ABANDONED_HOUSE_SPAWN_RATE = 20000;
        const INHABITANT_GROW_RATE = 5000; 

        // Resurser
        let resources = {};
        
        // Kostnader (UPPDATERAD)
        const COSTS = {
            TOWER: { metal: 50, wood: 20 },
            WALL: { wood: 10, reinforcedMetal: 1 },
            HOUSE: { wood: 30, earth: 10 },
            GREENHOUSE: { wood: 20, earth: 30 },
            BARRACKS: { wood: 50, metal: 20 },
            FARM: { earth: 20, boneMeal: 10 }, // NY (Rättad från prompt: 20 earth, 10 bonemeal)
            MINE: { wood: 40 } // NY (Rättad från prompt: 40 wood)
        };

        // Uppgraderingskostnader (UPPDATERAD med nya byggnader)
        const UPGRADE_COSTS = {
            TOWER: { level2: { metal: 75, reinforcedMetal: 5 }, level3: { metal: 150, reinforcedMetal: 15 } },
            WALL: { level2: { reinforcedMetal: 3 }, level3: { reinforcedMetal: 5 } },
            HOUSE: { level2: { wood: 50, earth: 20 }, level3: { wood: 100, earth: 40 } },
            GREENHOUSE: { level2: { earth: 50, reinforcedMetal: 3 }, level3: { earth: 100, reinforcedMetal: 6 } },
            BARRACKS: { level2: { wood: 75, metal: 50 }, level3: { wood: 150, metal: 100 } },
            FARM: { level2: { earth: 50, boneMeal: 40 }, level3: { earth: 100, boneMeal: 80 } }, // NY
            MINE: { level2: { wood: 100, reinforcedMetal: 5 }, level3: { wood: 200, reinforcedMetal: 10 } } // NY
        };
        
        const TROOP_RESCUE_FOOD_COST = 5; 
        const BASE_RESCUE_REWARD = { metal: 5, wood: 5, earth: 5 }; 
        
        const MONSTER_STATS = {
            'NORMAL': { color: '#e53e3e', speed: 40, hp: 10, damage: 5 },
            'MUTANT': { color: '#8b5cf6', speed: 25, hp: 50, damage: 15 }, 
            'JUMPER': { color: '#f6ad55', speed: 100, hp: 5, damage: 10 }, 
            'BOSS': { color: '#38b2ac', speed: 30, hp: 200, damage: 25 } 
        };

        // Uppdatera knapptexter
        function updateBuildButtonLabels() {
            buildTowerBtn.textContent = `Torn (${COSTS.TOWER.metal} Me, ${COSTS.TOWER.wood} Tr)`;
            buildWallBtn.textContent = `Mur (${COSTS.WALL.wood} Tr, ${COSTS.WALL.reinforcedMetal} F.Me)`;
            buildHouseBtn.textContent = `Hus (${COSTS.HOUSE.wood} Tr, ${COSTS.HOUSE.earth} Jo)`;
            buildGreenhouseBtn.textContent = `Växthus (${COSTS.GREENHOUSE.earth} Jo, ${COSTS.GREENHOUSE.wood} Tr)`;
            buildBarracksBtn.textContent = `Barack (${COSTS.BARRACKS.wood} Tr, ${COSTS.BARRACKS.metal} Me)`;
            buildFarmBtn.textContent = `Farm (${COSTS.FARM.earth} Jo, ${COSTS.FARM.boneMeal} Ben)`;
            buildMineBtn.textContent = `Gruva (${COSTS.MINE.wood} Tr)`;
        }

        // --- Klass-definitioner ---
        
        class Building {
            constructor(x, y, type, initialCost, baseMaxHp = 50) {
                this.x = x; this.y = y; this.type = type;
                this.key = `${x},${y}`;
                this.size = 1; 
                this.level = 1;
                this.maxLevel = 3; 
                this.initialCosts = initialCost;
                this.hp = baseMaxHp;
                this.maxHp = baseMaxHp;
            }
            getPixelPos() { return { x: (this.x + 0.5) * TILE_SIZE, y: (this.y + 0.5) * TILE_SIZE }; }
            update(deltaTime) {}
            draw(ctx) {}
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.destroy();
                }
            }

            destroy() {
                delete world[this.key];
                // Ta bort från specifika arrayer
                const lists = [towers, walls, houses, greenhouses, barracks, farms, mines];
                lists.forEach(list => {
                    const idx = list.indexOf(this);
                    if(idx > -1) list.splice(idx, 1);
                });
                if (this instanceof House) {
                    resources.maxInhabitants -= this.inhabitantCapacity;
                    resources.inhabitants = Math.min(resources.inhabitants, resources.maxInhabitants);
                }
            }
        }
        
        class Base extends Building {
            constructor(x, y) {
                super(x, y, 'BASE', {}, 100);
                this.size = 2; 
                this.turret = new Turret(this, 3); 
                this.maxLevel = Infinity; 
            }
            update(deltaTime) { this.turret.update(deltaTime); }
            draw(ctx) {
                const ts = TILE_SIZE;
                const x = this.x * ts;
                const y = this.y * ts;
                const baseSize = this.size * ts;

                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x + 5, y + ts / 2, baseSize - 10, baseSize - ts / 2 - 5); 
                
                ctx.fillStyle = '#A0522D';
                ctx.beginPath();
                ctx.moveTo(x + 5, y + ts / 2); 
                ctx.lineTo(x + baseSize / 2, y + 5); 
                ctx.lineTo(x + baseSize - 5, y + ts / 2); 
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = 'rgba(173, 216, 230, 0.7)'; 
                ctx.fillRect(x + ts * 0.4, y + ts * 0.8, ts * 0.2, ts * 0.2);
                ctx.fillRect(x + ts * 1.4, y + ts * 0.8, ts * 0.2, ts * 0.2);

                this.turret.draw(ctx, { x: x + baseSize / 2, y: y + ts * 0.3 }); 
                
                const barWidth = baseSize; const barHeight = 8; const barX = x; const barY = y + baseSize + 5; 
                ctx.fillStyle = '#4a5568'; ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = '#38a169'; ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
            }
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) { this.hp = 0; gameOver(); }
            }
            getPixelPos() { return { x: (this.x + this.size / 2) * TILE_SIZE, y: (this.y + this.size / 2) * TILE_SIZE }; }
        }
        
        class Tower extends Building {
            constructor(x, y) { 
                super(x, y, 'TOWER', COSTS.TOWER, 75);
                this.turret = new Turret(this, 5); 
            }
            update(deltaTime) { this.turret.update(deltaTime); }
            draw(ctx) {
                ctx.fillStyle = '#a0aec0'; ctx.strokeStyle = '#854d0e'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.rect(this.x * TILE_SIZE, this.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.fill(); ctx.stroke();
                this.turret.draw(ctx);
                this.drawHp(ctx);
            }
            drawHp(ctx) {
                if(this.hp < this.maxHp) {
                    ctx.fillStyle = '#f00'; ctx.fillRect(this.x * TILE_SIZE, this.y * TILE_SIZE + TILE_SIZE - 5, TILE_SIZE, 5);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(this.x * TILE_SIZE, this.y * TILE_SIZE + TILE_SIZE - 5, TILE_SIZE * (this.hp/this.maxHp), 5);
                }
            }
        }

        class Wall extends Building {
            constructor(x, y) { 
                super(x, y, 'WALL', COSTS.WALL, 200); // Lite mer HP än förut
            }
            update(deltaTime) {} 
            draw(ctx) {
                ctx.fillStyle = '#718096'; 
                const wallSize = TILE_SIZE / 3;
                const offset = (TILE_SIZE - wallSize) / 2;
                ctx.fillRect(this.x * TILE_SIZE + offset, this.y * TILE_SIZE + offset, wallSize, wallSize);
                
                // NYTT: Rita HP om skadad
                if (this.hp < this.maxHp) {
                    const hpW = TILE_SIZE * 0.8;
                    const hpX = this.x * TILE_SIZE + (TILE_SIZE - hpW)/2;
                    const hpY = this.y * TILE_SIZE + TILE_SIZE - 5;
                    ctx.fillStyle = 'red'; ctx.fillRect(hpX, hpY, hpW, 4);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(hpX, hpY, hpW * (this.hp / this.maxHp), 4);
                }
            }
        }

        class House extends Building {
            constructor(x, y) { super(x, y, 'HOUSE', COSTS.HOUSE, 50); this.inhabitantCapacity = 5; }
            draw(ctx) {
                const ts = TILE_SIZE; const x = this.x * ts; const y = this.y * ts;
                ctx.fillStyle = '#D2B48C'; ctx.fillRect(x + 5, y + ts / 3, ts - 10, ts * 2 / 3 - 5);
                ctx.fillStyle = '#A0522D'; ctx.beginPath(); ctx.moveTo(x + 5, y + ts / 3); ctx.lineTo(x + ts / 2, y + 5); ctx.lineTo(x + ts - 5, y + ts / 3); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#654321'; ctx.fillRect(x + ts / 2 - 4, y + ts * 2 / 3, 8, ts / 3 - 5);
            }
        }

        class Greenhouse extends Building {
            constructor(x, y) { super(x, y, 'GREENHOUSE', COSTS.GREENHOUSE, 40); this.produceTimer = 0; this.produceRate = 3000; } 
            update(deltaTime) {
                this.produceTimer += deltaTime;
                if (this.produceTimer >= this.produceRate) { this.produceTimer = 0; resources.food++; }
            }
            draw(ctx) {
                const ts = TILE_SIZE; const x = this.x * ts; const y = this.y * ts;
                ctx.fillStyle = '#6B8E23'; ctx.fillRect(x + 5, y + ts * 0.7, ts - 10, ts * 0.3 - 5);
                ctx.fillStyle = 'rgba(173, 216, 230, 0.4)'; ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(x + ts / 2, y + ts / 2 - 5, ts / 2 - 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.beginPath(); ctx.arc(x + ts * 0.7, y + ts * 0.3, ts * 0.15, 0, Math.PI * 2); ctx.fill();
            }
        }

        // NY CLASS: Farm
        class Farm extends Building {
            constructor(x, y) { 
                super(x, y, 'FARM', COSTS.FARM, 60); 
                this.produceTimer = 0; 
                this.produceRate = 2000; // 2 sekunder
            } 
            update(deltaTime) {
                this.produceTimer += deltaTime;
                if (this.produceTimer >= this.produceRate) { 
                    this.produceTimer = 0; 
                    resources.wood += 1; 
                }
            }
            draw(ctx) {
                const ts = TILE_SIZE; const x = this.x * ts; const y = this.y * ts;
                // Gulaktig åker
                ctx.fillStyle = '#DAA520'; 
                ctx.fillRect(x + 2, y + 2, ts - 4, ts - 4);
                // Vete strån
                ctx.strokeStyle = '#F4A460';
                ctx.lineWidth = 2;
                for(let i=10; i<40; i+=10) {
                    ctx.beginPath(); ctx.moveTo(x+i, y+10); ctx.lineTo(x+i, y+40); ctx.stroke();
                }
                // Progress bar för produktion
                ctx.fillStyle = '#8B4513'; ctx.fillRect(x, y+ts-5, ts, 5);
                ctx.fillStyle = '#32CD32'; ctx.fillRect(x, y+ts-5, ts * (this.produceTimer/this.produceRate), 5);
            }
        }

        // NY CLASS: Mine (Gruva)
        class Mine extends Building {
            constructor(x, y) { 
                super(x, y, 'MINE', COSTS.MINE, 100); 
                this.produceTimer = 0; 
                this.produceRate = 20000; // 20 sekunder
            } 
            update(deltaTime) {
                this.produceTimer += deltaTime;
                if (this.produceTimer >= this.produceRate) { 
                    this.produceTimer = 0; 
                    resources.earth += 10; 
                    resources.metal += 20;
                }
            }
            draw(ctx) {
                const ts = TILE_SIZE; const x = this.x * ts; const y = this.y * ts;
                // Grå stenhög
                ctx.fillStyle = '#2F4F4F'; 
                ctx.beginPath(); ctx.arc(x + ts/2, y + ts/2, ts/2 - 2, 0, Math.PI*2); ctx.fill();
                // Mörk ingång
                ctx.fillStyle = '#000'; 
                ctx.beginPath(); ctx.arc(x + ts/2, y + ts/2, ts/4, 0, Math.PI, true); ctx.fill();
                // Progress bar
                ctx.fillStyle = '#000'; ctx.fillRect(x, y+ts-5, ts, 5);
                ctx.fillStyle = '#aaa'; ctx.fillRect(x, y+ts-5, ts * (this.produceTimer/this.produceRate), 5);
            }
        }

        class Barracks extends Building {
            constructor(x, y) { super(x, y, 'BARRACKS', COSTS.BARRACKS, 60); }
            draw(ctx) {
                const ts = TILE_SIZE; const x = this.x * ts; const y = this.y * ts;
                ctx.fillStyle = '#8B4513'; ctx.fillRect(x + 5, y + ts * 0.6, ts - 10, ts * 0.4 - 5);
                ctx.beginPath(); ctx.moveTo(x + 5, y + ts * 0.6); ctx.lineTo(x + ts / 2, y + 5); ctx.lineTo(x + ts - 5, y + ts * 0.6); ctx.closePath(); ctx.fill();
                ctx.strokeStyle = '#A0522D'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(x + ts / 2, y + 5); ctx.lineTo(x + ts / 2, y + ts * 0.6); 
                ctx.stroke();
            }
        }
        
        class AbandonedHouse {
            constructor(x, y) { this.x = x; this.y = y; this.key = `${x},${y}`; }
            draw(ctx) {
                const ts = TILE_SIZE; const x = this.x * ts; const y = this.y * ts;
                ctx.fillStyle = '#5A5A5A'; ctx.fillRect(x + 5, y + ts / 3, ts - 10, ts * 2 / 3 - 5);
                ctx.fillStyle = '#3A3A3A'; ctx.beginPath(); ctx.moveTo(x + 5, y + ts / 3); ctx.lineTo(x + ts / 2, y + 5); ctx.lineTo(x + ts - 5, y + ts / 3); ctx.closePath(); ctx.fill();
                ctx.strokeStyle = '#c53030'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(x + 5, y + 5); ctx.lineTo(x + ts - 5, y + ts - 5); ctx.moveTo(x + ts - 5, y + 5); ctx.lineTo(x + 5, y + ts - 5); ctx.stroke();
            }
            getPixelPos() { return { x: (this.x + 0.5) * TILE_SIZE, y: (this.y + 0.5) * TILE_SIZE }; }
            rescueSuccess(troopsSent) {
                let rewardMultiplier = 1;
                if (troopsSent === 5) rewardMultiplier = 3;
                if (troopsSent === 10) rewardMultiplier = 5;
                resources.inhabitants++;
                resources.metal += BASE_RESCUE_REWARD.metal * rewardMultiplier;
                resources.wood += BASE_RESCUE_REWARD.wood * rewardMultiplier;
                resources.earth += BASE_RESCUE_REWARD.earth * rewardMultiplier;
                delete world[this.key];
                return true;
            }
        }

        class Turret {
            constructor(parent, damage) {
                this.parent = parent; this.range = 250; this.cooldown = 0; this.fireRate = 500; this.target = null; this.angle = 0; this.damage = damage; 
            }
            update(deltaTime) {
                if (this.cooldown > 0) this.cooldown -= deltaTime;
                if (!this.target || this.target.hp <= 0 || getDistance(this.parent.getPixelPos(), this.target) > this.range) {
                    this.target = this.findTarget();
                }
                if (this.target) {
                    const pos = this.parent.getPixelPos();
                    this.angle = Math.atan2(this.target.y - pos.y, this.target.x - pos.x);
                    if (this.cooldown <= 0) this.shoot();
                }
            }
            findTarget() {
                let closestMonster = null; let minDistance = this.range; const pos = this.parent.getPixelPos();
                for (const monster of monsters) {
                    const distance = getDistance(pos, monster);
                    if (distance < minDistance) { minDistance = distance; closestMonster = monster; }
                }
                return closestMonster;
            }
            shoot() {
                if (gameMode !== 'SANDBOX' && resources.bullets <= 0) return;
                this.cooldown = this.fireRate;
                if (gameMode !== 'SANDBOX') resources.bullets--;
                const pos = this.parent.getPixelPos();
                projectiles.push(new Projectile(pos.x, pos.y, this.target, this.damage));
            }
            draw(ctx, offset = null) {
                const pos = offset || this.parent.getPixelPos();
                ctx.save(); ctx.translate(pos.x, pos.y); ctx.rotate(this.angle);
                ctx.fillStyle = '#2d3748'; ctx.fillRect(0, -3, 25, 6);
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, target, damage) { this.x = x; this.y = y; this.target = target; this.speed = 400; this.damage = damage; this.hp = 1; }
            update(deltaTime) {
                if (!this.target || this.target.hp <= 0) { this.hp = 0; return; }
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                this.x += Math.cos(angle) * this.speed * (deltaTime / 1000);
                this.y += Math.sin(angle) * this.speed * (deltaTime / 1000);
                if (getDistance(this, this.target) < this.target.size / 2) { this.target.takeDamage(this.damage); this.hp = 0; }
            }
            draw(ctx) { ctx.fillStyle = '#f6e05e'; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI * 2); ctx.fill(); }
        }
        
        class Monster {
            constructor(x, y, type = 'NORMAL') {
                this.x = x; this.y = y;
                this.type = type;
                const stats = MONSTER_STATS[type];
                
                // NYTT: Skalning baserat på basnivå
                const scaling = 1 + (base.level - 1) * 0.2; // 20% starkare per nivå

                this.size = 20; 
                this.speed = stats.speed;
                this.color = stats.color;
                this.maxHp = stats.hp * scaling;
                this.hp = this.maxHp; 
                this.damage = stats.damage * scaling;
                
                this.attackRange = 40; 
                this.attackCooldown = 1000; 
                this.attackTimer = 0;
                
                this.wallAttackCooldown = 1000;
                this.wallAttackTimer = 0;
            }
            
            update(deltaTime) {
                const basePos = base.getPixelPos();
                const distanceToBase = getDistance(this, basePos);
                const delta = deltaTime / 1000;
                
                // Attackera basen om nära
                if (distanceToBase <= this.attackRange) {
                    this.attackTimer += deltaTime;
                    if (this.attackTimer >= this.attackCooldown) {
                        this.attackTimer = 0;
                        base.takeDamage(this.damage);
                    }
                    return; // Stå still om vi attackerar basen
                }

                // Rörelselogik
                const angle = Math.atan2(basePos.y - this.y, basePos.x - this.x);
                const dx = Math.cos(angle) * this.speed * delta;
                const dy = Math.sin(angle) * this.speed * delta;
                
                let nextX = this.x + dx;
                let nextY = this.y + dy;

                // NYTT: Väggkollision med attack
                // Kolla X-led
                let wallHitX = getWallAt(nextX, this.y, this.size);
                if (wallHitX) {
                    this.attackWall(wallHitX, deltaTime);
                    nextX = this.x; // Stoppa rörelse
                }
                
                // Kolla Y-led
                let wallHitY = getWallAt(nextX, nextY, this.size); // Använd nextX här om vi rört oss, annars gamla X
                if (wallHitY) {
                    this.attackWall(wallHitY, deltaTime);
                    nextY = this.y; // Stoppa rörelse
                }

                this.x = nextX;
                this.y = nextY;
            }

            attackWall(wall, deltaTime) {
                this.wallAttackTimer += deltaTime;
                if (this.wallAttackTimer >= this.wallAttackCooldown) {
                    this.wallAttackTimer = 0;
                    wall.takeDamage(this.damage);
                }
            }

            draw(ctx) {
                ctx.save(); ctx.fillStyle = this.color; const r = this.size / 2;
                if (this.type === 'NORMAL') {
                    ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(this.x - r/3, this.y - r/4, r/5, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(this.x + r/3, this.y - r/4, r/5, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'MUTANT') {
                    const mutantR = this.size * 0.7; ctx.beginPath(); for (let i = 0; i < 8; i++) { const angle = i * (Math.PI / 4); const x = this.x + mutantR * Math.cos(angle); const y = this.y + mutantR * Math.sin(angle); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); } ctx.closePath(); ctx.fill();
                } else if (this.type === 'JUMPER') {
                    const jumperR = r * 0.8; ctx.beginPath(); ctx.moveTo(this.x, this.y - jumperR); ctx.lineTo(this.x - jumperR * 0.866, this.y + jumperR * 0.5); ctx.lineTo(this.x + jumperR * 0.866, this.y + jumperR * 0.5); ctx.closePath(); ctx.fill();
                } else if (this.type === 'BOSS') {
                    const s = this.size * 1.5; ctx.fillRect(this.x - s/2, this.y - s/2, s, s); ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(this.x, this.y, s/3, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
                ctx.fillStyle = 'white'; ctx.font = '8px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.type, this.x, this.y + 4); 
                if (this.hp < this.maxHp) {
                    const barWidth = this.size; const barHeight = 4;
                    ctx.fillStyle = '#4a5568'; ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 5, barWidth, barHeight);
                    ctx.fillStyle = '#38a169'; ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 5, barWidth * (this.hp / this.maxHp), barHeight);
                }
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) this.die();
            }
            
            die() {
                resources.kills++;
                // NYTT: Droppa Monster Waste istället för resurser
                resources.monsterWaste++;
                
                // Kanske en liten chans för extra waste för Bossar/Mutanter
                if (this.type === 'BOSS') resources.monsterWaste += 9;
                if (this.type === 'MUTANT') resources.monsterWaste += 2;
            }
        }
        
        class Troop {
            constructor(startX, startY, targetHouse, troopCount) { this.x = startX; this.y = startY; this.targetHouse = targetHouse; this.troopCount = troopCount; this.speed = 80; this.size = 10; this.hp = 1; }
            update(deltaTime) {
                if (this.hp <= 0) return;
                if (!this.targetHouse.key || !world[this.targetHouse.key]) { this.hp = 0; return; }
                const targetPos = this.targetHouse.getPixelPos();
                const distanceToTarget = getDistance(this, targetPos);
                if (distanceToTarget < 10) { this.targetHouse.rescueSuccess(this.troopCount); this.hp = 0; } else {
                    const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
                    this.x += Math.cos(angle) * this.speed * (deltaTime / 1000);
                    this.y += Math.sin(angle) * this.speed * (deltaTime / 1000);
                }
            }
            draw(ctx) {
                if (this.hp <= 0) return;
                ctx.fillStyle = '#48bb78'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = '8px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.troopCount, this.x, this.y + 3);
            }
        }


        // --- Hjälpfunktioner ---
        
        // NYTT: Returnera objektet (Väggen) vid kollision
        function getWallAt(x, y, radius) {
            const checkPoints = [
                { x: x - radius / 2, y: y - radius / 2 },
                { x: x + radius / 2, y: y - radius / 2 },
                { x: x - radius / 2, y: y + radius / 2 },
                { x: x + radius / 2, y: y + radius / 2 }
            ];
            for (const point of checkPoints) {
                const { tileX, tileY } = worldToGrid(point.x, point.y);
                if (tileX === undefined || tileY === undefined) continue; 
                const obj = world[`${tileX},${tileY}`];
                if (obj instanceof Wall) return obj;
            }
            return null;
        }

        function checkWallCollision(x, y, radius) {
            return getWallAt(x, y, radius) !== null;
        }

        function getDistance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function isTileOccupied(tileX, tileY) { return !!world[`${tileX},${tileY}`]; }
        function getObjectAtTile(tileX, tileY) { return world[`${tileX},${tileY}`] || null; }

        function occupyTile(tileX, tileY, size, object) {
            for(let x = 0; x < size; x++) {
                for(let y = 0; y < size; y++) {
                    world[`${tileX + x},${tileY + y}`] = object;
                }
            }
        }

        function screenToWorld(x, y) {
            return { x: (x - canvas.width / 2) / camera.zoom + camera.x, y: (y - canvas.height / 2) / camera.zoom + camera.y };
        }
        
        function worldToGrid(worldX, worldY) {
            return { tileX: Math.floor(worldX / TILE_SIZE), tileY: Math.floor(worldY / TILE_SIZE) };
        }
        
        function getRandomMonsterType() {
            const rand = Math.random() * 100;
            if (rand < 70) return 'NORMAL';
            if (rand < 85) return 'MUTANT';
            return 'JUMPER';
        }

        function spawnMonster(type = getRandomMonsterType()) {
            const basePos = base.getPixelPos();
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.max(canvas.width, canvas.height) / camera.zoom + 100;
            const x = basePos.x + Math.cos(angle) * distance;
            const y = basePos.y + Math.sin(angle) * distance;
            monsters.push(new Monster(x, y, type));
        }

        function spawnAbandonedHouse() {
            const basePos = base.getPixelPos();
            const angle = Math.random() * Math.PI * 2;
            const distance = (Math.random() * 1000) + 500; 
            const worldX = basePos.x + Math.cos(angle) * distance;
            const worldY = basePos.y + Math.sin(angle) * distance;
            const { tileX, tileY } = worldToGrid(worldX, worldY);
            if (Math.abs(tileX - base.x) < 5 && Math.abs(tileY - base.y) < 5) return;
            if (!isTileOccupied(tileX, tileY)) {
                const newHouse = new AbandonedHouse(tileX, tileY);
                abandonedHouses.push(newHouse);
                occupyTile(tileX, tileY, 1, newHouse);
            }
        }
        
        function updateUI() {
            const inf = '∞';
            const isSandbox = gameMode === 'SANDBOX';

            metalValue.textContent = isSandbox ? inf : resources.metal;
            woodValue.textContent = isSandbox ? inf : resources.wood;
            earthValue.textContent = isSandbox ? inf : resources.earth;
            reinforcedMetalValue.textContent = isSandbox ? inf : resources.reinforcedMetal;
            
            // NYA RESURSER
            monsterWasteValue.textContent = isSandbox ? inf : resources.monsterWaste;
            bonemealValue.textContent = isSandbox ? inf : resources.boneMeal;

            killsValue.textContent = resources.kills;
            baseHpValue.textContent = `${Math.ceil(base.hp)} / ${Math.ceil(base.maxHp)}`;
            baseHpValue.style.color = (base.hp / base.maxHp < 0.3) ? '#e53e3e' : '#ffffff';
            bulletsValue.textContent = isSandbox ? inf : resources.bullets;
            foodValue.textContent = isSandbox ? inf : resources.food;
            inhabitantsValue.textContent = `${resources.inhabitants} / ${resources.maxInhabitants}`;
            troopsValue.textContent = isSandbox ? inf : resources.troops;
        }

        function hideAllScreens() {
            startMenu.classList.add('hidden');
            controlsMenu.classList.add('hidden');
            creditsScreen.classList.add('hidden');
            introScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameUi.classList.add('hidden');
            sandboxMessage.classList.add('hidden');
            buildMenu.classList.add('hidden');
            actionsBoard.classList.add('hidden'); 
            troopSelectMenu.classList.add('hidden');
            buildingMenu.classList.add('hidden'); 
            pauseMenu.classList.add('hidden'); // NYTT
            canvas.style.display = 'none'; 
        }

        function returnToMenu() {
            gameState = 'MENU';
            hideAllScreens();
            startMenu.classList.remove('hidden');
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            hideAllScreens();
            gameOverScreen.classList.remove('hidden');
        }

        function positionMenu(menuElement, clientX, clientY) {
            menuElement.style.position = 'fixed'; 
            menuElement.classList.remove('hidden');
            const menuWidth = menuElement.offsetWidth;
            const menuHeight = menuElement.offsetHeight; 
            let x = clientX + 10; let y = clientY + 10;
            if (x + menuWidth > window.innerWidth - 10) { x = clientX - menuWidth - 10; if (x < 10) x = window.innerWidth - menuWidth - 10; }
            if (y + menuHeight > window.innerHeight - 10) { y = clientY - menuHeight - 10; if (y < 10) y = window.innerHeight - menuHeight - 10; }
            if (x < 10) x = 10; if (y < 10) y = 10;
            menuElement.style.left = `${x}px`; menuElement.style.top = `${y}px`;
        }

        // --- Resurs och Kostnadshantering ---

        function checkCost(cost) {
            if (gameMode === 'SANDBOX' || !cost) return true;
            for (const [resource, amount] of Object.entries(cost)) {
                if ((resources[resource] || 0) < amount) {
                    return false;
                }
            }
            return true;
        }
        
        function payCost(cost) {
            if (gameMode === 'SANDBOX' || !cost) return;
            for (const [resource, amount] of Object.entries(cost)) {
                resources[resource] -= amount;
            }
        }

        function getUpgradeCost(building) {
            if (building instanceof Base) {
                const level = building.level;
                return {
                    metal: Math.floor(100 * Math.pow(1.5, level - 1)),
                    wood: Math.floor(100 * Math.pow(1.5, level - 1)),
                    reinforcedMetal: Math.floor(10 * Math.pow(1.2, level - 1))
                };
            }

            if (building.level >= building.maxLevel) return null;
            const nextLevelKey = `level${building.level + 1}`;
            return UPGRADE_COSTS[building.type][nextLevelKey] || null;
        }

        function upgradeBuilding() {
            if (!focusedBuilding) return;
            if (!(focusedBuilding instanceof Base) && focusedBuilding.level >= focusedBuilding.maxLevel) return;

            const cost = getUpgradeCost(focusedBuilding);
            if (!cost || !checkCost(cost)) { console.log("Kan inte uppgradera."); return; }
            
            payCost(cost);
            
            focusedBuilding.level++;
            focusedBuilding.maxHp *= 1.5; 
            focusedBuilding.hp = focusedBuilding.maxHp; 
            
            if (focusedBuilding instanceof Base) {
                focusedBuilding.maxHp += 50;
                focusedBuilding.hp = focusedBuilding.maxHp; 
                focusedBuilding.turret.fireRate *= 0.9;
            } else if (focusedBuilding instanceof Tower) {
                focusedBuilding.turret.damage *= 1.5;
                focusedBuilding.turret.fireRate *= 0.9;
            } else if (focusedBuilding instanceof Greenhouse) {
                focusedBuilding.produceRate /= 1.5; 
            } else if (focusedBuilding instanceof Farm) { // NY
                focusedBuilding.produceRate /= 1.5; 
            } else if (focusedBuilding instanceof Mine) { // NY
                focusedBuilding.produceRate /= 1.5; 
            } else if (focusedBuilding instanceof House) {
                resources.maxInhabitants += 5; focusedBuilding.inhabitantCapacity += 5;
            }

            buildingMenu.classList.add('hidden');
            focusedBuilding = null;
        }
        
        // NYTT: Reparationsfunktion
        function repairWall() {
            if (!focusedBuilding || !(focusedBuilding instanceof Wall)) return;
            if (focusedBuilding.hp >= focusedBuilding.maxHp) return;
            
            const repairCost = { reinforcedMetal: 1 };
            if (!checkCost(repairCost)) { console.log("Saknar resurser för reparation"); return; }
            
            payCost(repairCost);
            focusedBuilding.hp = focusedBuilding.maxHp;
            console.log("Vägg reparerad!");
            buildingMenu.classList.add('hidden');
            focusedBuilding = null;
        }

        function destroyBuilding() {
            if (!focusedBuilding || focusedBuilding instanceof Base) return;

            const building = focusedBuilding;
            const refundPercentage = 0.75;
            
            for (const [resource, amount] of Object.entries(building.initialCosts)) {
                const refund = Math.round(amount * refundPercentage);
                if (gameMode !== 'SANDBOX') resources[resource] = (resources[resource] || 0) + refund;
            }
            
            // Hantera uppgraderingskostnader återbetalning... (förenklad för utrymmets skull)
            
            building.destroy();
            
            console.log(`Byggnad ${building.type} förstörd. 75% av materialet återbetalat.`);
            buildingMenu.classList.add('hidden');
            focusedBuilding = null;
        }


        // --- Spel-logik (Uppdatering) ---

        function update(deltaTime) {
            const cameraSpeed = 500 / camera.zoom;
            if (keysPressed['w'] || keysPressed['ArrowUp']) camera.y -= cameraSpeed * (deltaTime / 1000);
            if (keysPressed['s'] || keysPressed['ArrowDown']) camera.y += cameraSpeed * (deltaTime / 1000);
            if (keysPressed['a'] || keysPressed['ArrowLeft']) camera.x -= cameraSpeed * (deltaTime / 1000);
            if (keysPressed['d'] || keysPressed['ArrowRight']) camera.x += cameraSpeed * (deltaTime / 1000);

            if (gameMode === 'NORMAL') {
                monsterSpawnTimer += deltaTime;
                const bossRate = 300000;
                if (monsterSpawnTimer >= bossRate) { spawnMonster('BOSS'); monsterSpawnTimer = 0; } 
                else if (monsterSpawnTimer % 3000 < deltaTime) { spawnMonster(); }
            }
            
            abandonedHouseSpawnTimer += deltaTime;
            if (abandonedHouseSpawnTimer >= ABANDONED_HOUSE_SPAWN_RATE) { abandonedHouseSpawnTimer = 0; spawnAbandonedHouse(); }
            
            inhabitantGrowTimer += deltaTime;
            if (inhabitantGrowTimer >= INHABITANT_GROW_RATE && resources.inhabitants < resources.maxInhabitants) { inhabitantGrowTimer = 0; resources.inhabitants++; }
            
            greenhouses.forEach(g => g.update(deltaTime));
            farms.forEach(f => f.update(deltaTime)); // NY
            mines.forEach(m => m.update(deltaTime)); // NY

            base.update(deltaTime);
            towers.forEach(tower => tower.update(deltaTime));
            monsters.forEach(monster => monster.update(deltaTime));
            projectiles.forEach(proj => proj.update(deltaTime));
            troops.forEach(t => t.update(deltaTime)); 

            monsters = monsters.filter(m => m.hp > 0);
            projectiles = projectiles.filter(p => p.hp > 0);
            troops = troops.filter(t => t.hp > 0); 
            
            abandonedHouses = abandonedHouses.filter(ah => world[ah.key]);
            walls = walls.filter(w => w.hp > 0); // Rensa förstörda väggar

            updateUI();
        }

        // --- Spel-logik (Rendering) ---

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            // Rita rutnät
            ctx.strokeStyle = '#4a5568';
            ctx.lineWidth = 1 / camera.zoom;
            ctx.beginPath();
            const { x: startWorldX, y: startWorldY } = screenToWorld(0, 0);
            const { x: endWorldX, y: endWorldY } = screenToWorld(canvas.width, canvas.height);
            const startX = Math.floor(startWorldX / TILE_SIZE) * TILE_SIZE;
            const startY = Math.floor(startWorldY / TILE_SIZE) * TILE_SIZE;
            const endX = Math.ceil(endWorldX / TILE_SIZE) * TILE_SIZE;
            const endY = Math.ceil(endWorldY / TILE_SIZE) * TILE_SIZE;
            for (let x = startX; x <= endX; x += TILE_SIZE) { ctx.moveTo(x, startY); ctx.lineTo(x, endY); }
            for (let y = startY; y <= endY; y += TILE_SIZE) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
            ctx.stroke();

            // Rita byggnader
            base.draw(ctx);
            towers.forEach(tower => tower.draw(ctx));
            walls.forEach(wall => wall.draw(ctx));
            houses.forEach(house => house.draw(ctx));
            greenhouses.forEach(gh => gh.draw(ctx));
            barracks.forEach(b => b.draw(ctx));
            farms.forEach(f => f.draw(ctx)); // NY
            mines.forEach(m => m.draw(ctx)); // NY
            abandonedHouses.forEach(ah => ah.draw(ctx));
            
            monsters.forEach(monster => monster.draw(ctx));
            projectiles.forEach(proj => proj.draw(ctx));
            troops.forEach(troop => troop.draw(ctx)); 
            
            if (selectedTile) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(selectedTile.tileX * TILE_SIZE, selectedTile.tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }

            ctx.restore();
        }

        function gameLoop(timestamp) {
            if (gameState === 'GAME' || gameState === 'SANDBOX') {
                let deltaTime = timestamp - lastTime;
                if (deltaTime > 100) deltaTime = 100; 
                lastTime = timestamp;
                update(deltaTime);
                render();
                requestAnimationFrame(gameLoop);
            }
        }

        function initGame(mode) {
            gameMode = mode;
            gameState = (mode === 'SANDBOX') ? 'SANDBOX' : 'GAME';
            
            hideAllScreens();
            gameUi.classList.remove('hidden');
            canvas.style.display = 'block'; 
            if (gameMode === 'SANDBOX') sandboxMessage.classList.remove('hidden');
            
            targetAbandonedHouse = null;
            focusedBuilding = null; 
            selectedTile = null;

            // Nollställ
            world = {};
            towers = []; walls = []; houses = []; greenhouses = []; barracks = []; farms = []; mines = []; abandonedHouses = [];
            monsters = []; projectiles = []; troops = []; 
            monsterSpawnTimer = 0;
            abandonedHouseSpawnTimer = 0;
            inhabitantGrowTimer = 0;
            
            base = new Base(-1, -1);
            occupyTile(-1, -1, base.size, base);

            // Nollställ resurser
            resources = {
                kills: 0,
                troops: 10,
                metal: 100,
                wood: 100,
                earth: 100,
                bullets: 500,
                food: 50,
                reinforcedMetal: 0,
                monsterWaste: 0, // NY
                boneMeal: 0, // NY
                inhabitants: 5,
                maxInhabitants: 5
            };
            
            camera.x = 0; camera.y = 0; camera.zoom = 1;
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
        
        // --- Bygg-logik ---
        
        function tryBuild(type) {
            if (!selectedTile) return;
            const { tileX, tileY } = selectedTile;
            if (isTileOccupied(tileX, tileY)) return;

            let newBuilding;
            let cost;

            if (type === 'TOWER') { cost = COSTS.TOWER; if (!checkCost(cost)) return; newBuilding = new Tower(tileX, tileY); towers.push(newBuilding); } 
            else if (type === 'WALL') { cost = COSTS.WALL; if (!checkCost(cost)) return; newBuilding = new Wall(tileX, tileY); walls.push(newBuilding); } 
            else if (type === 'HOUSE') { cost = COSTS.HOUSE; if (!checkCost(cost)) return; newBuilding = new House(tileX, tileY); houses.push(newBuilding); resources.maxInhabitants += newBuilding.inhabitantCapacity; } 
            else if (type === 'GREENHOUSE') { cost = COSTS.GREENHOUSE; if (!checkCost(cost)) return; newBuilding = new Greenhouse(tileX, tileY); greenhouses.push(newBuilding); } 
            else if (type === 'BARRACKS') { cost = COSTS.BARRACKS; if (!checkCost(cost)) return; newBuilding = new Barracks(tileX, tileY); barracks.push(newBuilding); } 
            else if (type === 'FARM') { cost = COSTS.FARM; if (!checkCost(cost)) return; newBuilding = new Farm(tileX, tileY); farms.push(newBuilding); } // NY
            else if (type === 'MINE') { cost = COSTS.MINE; if (!checkCost(cost)) return; newBuilding = new Mine(tileX, tileY); mines.push(newBuilding); } // NY
            else { return; }
            
            payCost(cost);
            occupyTile(tileX, tileY, 1, newBuilding);
            buildMenu.classList.add('hidden');
            selectedTile = null;
        }

        // --- Event Listeners ---

        upgradeBtn.addEventListener('click', upgradeBuilding);
        destroyBtn.addEventListener('click', destroyBuilding);
        repairBtn.addEventListener('click', repairWall); // NY
        buildingMenuCancelBtn.addEventListener('click', () => {
            buildingMenu.classList.add('hidden');
            focusedBuilding = null;
        });

        const camera = { x: 0, y: 0, zoom: 1, isDragging: false, lastMouse: { x: 0, y: 0 } };
        const keysPressed = {};

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); 
            if (gameState !== 'GAME' && gameState !== 'SANDBOX') return;

            const worldPos = screenToWorld(e.clientX, e.clientY);
            const gridPos = worldToGrid(worldPos.x, worldPos.y);
            const targetObject = getObjectAtTile(gridPos.tileX, gridPos.tileY);
            
            buildMenu.classList.add('hidden');
            troopSelectMenu.classList.add('hidden');
            buildingMenu.classList.add('hidden');
            repairBtn.classList.add('hidden'); // Dölj repair som default
            selectedTile = null;
            targetAbandonedHouse = null;
            focusedBuilding = null;

            if (targetObject instanceof AbandonedHouse) {
                targetAbandonedHouse = targetObject; 
                positionMenu(troopSelectMenu, e.clientX, e.clientY);

            } else if (targetObject instanceof Building) {
                focusedBuilding = targetObject;
                
                // Visa repair om det är en skadad vägg
                if (focusedBuilding instanceof Wall && focusedBuilding.hp < focusedBuilding.maxHp) {
                    repairBtn.classList.remove('hidden');
                    repairBtn.disabled = !checkCost({reinforcedMetal: 1});
                } else {
                    repairBtn.classList.add('hidden');
                }

                const cost = getUpgradeCost(focusedBuilding);
                const maxLevelReached = !(focusedBuilding instanceof Base) && focusedBuilding.level >= focusedBuilding.maxLevel;
                const costString = cost ? `(${Object.entries(cost).map(([res, amt]) => `${amt} ${res.substring(0, 2)}`).join(', ')})` : '';

                buildingMenuTitle.textContent = `${focusedBuilding.type} (Nivå ${focusedBuilding.level})`;
                
                if (!maxLevelReached) {
                    upgradeBtn.textContent = `Uppgradera till N ${focusedBuilding.level + 1} ${costString}`;
                    upgradeBtn.classList.remove('hidden');
                    upgradeBtn.disabled = !checkCost(cost);
                } else {
                    upgradeBtn.textContent = `Max Nivå (${focusedBuilding.maxLevel})`;
                    upgradeBtn.disabled = true;
                }

                if (focusedBuilding instanceof Base) {
                    destroyBtn.classList.add('hidden');
                } else {
                    destroyBtn.classList.remove('hidden');
                    destroyBtn.textContent = `Förstöra (75% Återbetalning)`;
                }
                positionMenu(buildingMenu, e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameState !== 'GAME' && gameState !== 'SANDBOX') return;
            if (e.button === 0) {
                if (!troopSelectMenu.classList.contains('hidden') || !buildingMenu.classList.contains('hidden')) {
                    troopSelectMenu.classList.add('hidden'); buildingMenu.classList.add('hidden'); targetAbandonedHouse = null; focusedBuilding = null;
                }
                if (!buildMenu.classList.contains('hidden')) { buildMenu.classList.add('hidden'); selectedTile = null; return; }
                const worldPos = screenToWorld(e.clientX, e.clientY);
                const gridPos = worldToGrid(worldPos.x, worldPos.y);
                if (!isTileOccupied(gridPos.tileX, gridPos.tileY)) { selectedTile = gridPos; positionMenu(buildMenu, e.clientX, e.clientY); } 
                else { camera.isDragging = true; camera.lastMouse = { x: e.clientX, y: e.clientY }; }
            } else if (e.button === 1) { camera.isDragging = true; camera.lastMouse = { x: e.clientX, y: e.clientY }; }
        });

        // Standardknappar
        startGameIntroBtn.addEventListener('click', () => { hideAllScreens(); introScreen.classList.remove('hidden'); gameState = 'INTRO'; });
        continueGameBtn.addEventListener('click', () => { initGame('NORMAL'); });
        creditsBtn.addEventListener('click', () => { hideAllScreens(); creditsScreen.classList.remove('hidden'); gameState = 'CREDITS'; });
        creditsBackBtn.addEventListener('click', returnToMenu);
        sandboxGameBtn.addEventListener('click', () => initGame('SANDBOX'));
        // returnToMenuBtn är borttagen från HTML så denna behövs inte längre
        // returnToMenuBtn.addEventListener('click', returnToMenu); 
        
        controlsBtn.addEventListener('click', () => { hideAllScreens(); controlsMenu.classList.remove('hidden'); gameState = 'CONTROLS'; });
        controlsBackBtn.addEventListener('click', () => {
            // NYTT: Kontrollera om vi kom från pausmenyn
            if (gameState === 'CONTROLS_PAUSED') {
                hideAllScreens();
                pauseMenu.classList.remove('hidden');
                gameState = 'PAUSED';
            } else {
                returnToMenu();
            }
        }); 
        gameOverBackBtn.addEventListener('click', returnToMenu); 
        
        // PAUS LOGIK
        function togglePause() {
            if (gameState === 'GAME' || gameState === 'SANDBOX') {
                savedGameState = gameState;
                gameState = 'PAUSED';
                pauseMenu.classList.remove('hidden');
            } else if (gameState === 'PAUSED') {
                gameState = savedGameState;
                pauseMenu.classList.add('hidden');
                
                // FIX: Återställ UI och Canvas ifall vi kom från en annan meny (t.ex. Kontroller)
                gameUi.classList.remove('hidden');
                canvas.style.display = 'block';
                if (gameMode === 'SANDBOX') sandboxMessage.classList.remove('hidden');

                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        pauseContinueBtn.addEventListener('click', togglePause);
        pauseHomeBtn.addEventListener('click', returnToMenu);
        pauseControlsBtn.addEventListener('click', () => {
            hideAllScreens();
            controlsMenu.classList.remove('hidden');
            gameState = 'CONTROLS_PAUSED';
        });


        // Bygg-knappar
        buildTowerBtn.addEventListener('click', () => tryBuild('TOWER'));
        buildWallBtn.addEventListener('click', () => tryBuild('WALL'));
        buildHouseBtn.addEventListener('click', () => tryBuild('HOUSE'));
        buildGreenhouseBtn.addEventListener('click', () => tryBuild('GREENHOUSE'));
        buildBarracksBtn.addEventListener('click', () => tryBuild('BARRACKS')); 
        buildFarmBtn.addEventListener('click', () => tryBuild('FARM')); 
        buildMineBtn.addEventListener('click', () => tryBuild('MINE')); 
        buildCancelBtn.addEventListener('click', () => { buildMenu.classList.add('hidden'); selectedTile = null; });

        // Åtgärder
        trainTroopBtn.addEventListener('click', () => {
            if (gameMode !== 'SANDBOX' && barracks.length === 0) { console.log("Du måste bygga en barack först!"); return; }
            if (gameMode !== 'SANDBOX' && resources.inhabitants >= resources.maxInhabitants) { console.log("Max antal invånare nått!"); return; }
            if (gameMode !== 'SANDBOX' && resources.food < 10) { console.log("Inte tillräckligt med mat för att träna!"); return; }
            if (gameMode !== 'SANDBOX') { resources.inhabitants--; resources.food -= 10; }
            resources.troops++;
        });

        craftBulletsBtn.addEventListener('click', () => {
            if (gameMode !== 'SANDBOX' && resources.metal < 1) return;
            if (gameMode !== 'SANDBOX') resources.metal--;
            resources.bullets += 10;
        });

        craftReinforcedBtn.addEventListener('click', () => {
            if (gameMode !== 'SANDBOX' && resources.metal < 2) return;
            if (gameMode !== 'SANDBOX') resources.metal -= 2;
            resources.reinforcedMetal++;
        });

        // NYTT: Crafting för Benmjöl
        craftBonemealBtn.addEventListener('click', () => {
            if (gameMode !== 'SANDBOX' && resources.monsterWaste < 1) return;
            if (gameMode !== 'SANDBOX') resources.monsterWaste--;
            resources.boneMeal += 5;
        });
        
        // Truppval
        troopSelectButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                if (targetAbandonedHouse) {
                    const troopsToSend = parseInt(e.currentTarget.getAttribute('data-troops'));
                    const neededFood = TROOP_RESCUE_FOOD_COST;
                    if (gameMode !== 'SANDBOX') {
                        if (resources.troops < troopsToSend || resources.food < neededFood) return;
                    }
                    if (gameMode !== 'SANDBOX') { resources.troops -= troopsToSend; resources.food -= neededFood; }
                    const startPos = base.getPixelPos();
                    const newTroop = new Troop(startPos.x, startPos.y, targetAbandonedHouse, troopsToSend);
                    troops.push(newTroop);
                    troopSelectMenu.classList.add('hidden'); targetAbandonedHouse = null;
                }
            });
        });
        
        troopSelectCancelBtn.addEventListener('click', () => { troopSelectMenu.classList.add('hidden'); targetAbandonedHouse = null; });

        window.addEventListener('mousemove', (e) => {
            if (camera.isDragging) {
                const dx = e.clientX - camera.lastMouse.x; const dy = e.clientY - camera.lastMouse.y;
                camera.x -= dx / camera.zoom; camera.y -= dy / camera.zoom;
                camera.lastMouse = { x: e.clientX, y: e.clientY };
                if (selectedTile) { selectedTile = null; buildMenu.classList.add('hidden'); }
                if (targetAbandonedHouse) { targetAbandonedHouse = null; troopSelectMenu.classList.add('hidden'); } 
                if (focusedBuilding) { focusedBuilding = null; buildingMenu.classList.add('hidden'); } 
            }
        });

        window.addEventListener('mouseup', (e) => { camera.isDragging = false; });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scroll = e.deltaY < 0 ? 1 : -1;
            camera.zoom = Math.max(0.1, Math.min(camera.zoom * (1 + scroll * 0.1), 3.0));
        });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase(); keysPressed[key] = true;
            
            // NYTT: L för paus
            if ((gameState === 'GAME' || gameState === 'SANDBOX' || gameState === 'PAUSED') && key === 'l') {
                togglePause();
            }

            if (gameState === 'SANDBOX' && key === 'm') spawnMonster(); 
            if (gameState === 'SANDBOX' && key === 'b') spawnMonster('BOSS'); 
            if ((gameState === 'GAME' || gameState === 'SANDBOX') && key === 'y') actionsBoard.classList.toggle('hidden');
        });

        window.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });
        
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; if(gameState === 'GAME' || gameState === 'SANDBOX') render(); }
        window.addEventListener('resize', resizeCanvas);
        
        resizeCanvas();
        updateBuildButtonLabels(); 
        hideAllScreens(); 
        startMenu.classList.remove('hidden'); 
    </script>
</body>
</html>
</div>

</body>
</html>
